(()=>{var n={9825:n=>{n.exports='/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nfunction loadBergamot(Module) {\n  var BERGAMOT_VERSION_FULL = "v0.6.0+4a6a44c0";\n  null;\n\n  var Module = typeof Module != "undefined" ? Module : {};\n\n  var moduleOverrides = Object.assign({}, Module);\n\n  var arguments_ = [];\n\n  var thisProgram = "./this.program";\n\n  var quit_ = (status, toThrow) => {\n    throw toThrow;\n  };\n\n  var ENVIRONMENT_IS_WEB = typeof window == "object";\n\n  var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";\n\n  var ENVIRONMENT_IS_NODE =\n    typeof process == "object" &&\n    typeof process.versions == "object" &&\n    typeof process.versions.node == "string";\n\n  var scriptDirectory = "";\n\n  function locateFile(path) {\n    if (Module.locateFile) {\n      return Module.locateFile(path, scriptDirectory);\n    }\n    return scriptDirectory + path;\n  }\n\n  var read_, readAsync, readBinary, setWindowTitle;\n\n  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n    if (ENVIRONMENT_IS_WORKER) {\n      scriptDirectory = self.location.href;\n    } else if (typeof document != "undefined" && document.currentScript) {\n      scriptDirectory = document.currentScript.src;\n    }\n    if (scriptDirectory.indexOf("blob:") !== 0) {\n      scriptDirectory = scriptDirectory.substr(\n        0,\n        scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1\n      );\n    } else {\n      scriptDirectory = "";\n    }\n    {\n      read_ = url => {\n        var xhr = new XMLHttpRequest();\n        xhr.open("GET", url, false);\n        xhr.send(null);\n        return xhr.responseText;\n      };\n      if (ENVIRONMENT_IS_WORKER) {\n        readBinary = url => {\n          var xhr = new XMLHttpRequest();\n          xhr.open("GET", url, false);\n          xhr.responseType = "arraybuffer";\n          xhr.send(null);\n          return new Uint8Array(xhr.response);\n        };\n      }\n      readAsync = (url, onload, onerror) => {\n        var xhr = new XMLHttpRequest();\n        xhr.open("GET", url, true);\n        xhr.responseType = "arraybuffer";\n        xhr.onload = () => {\n          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {\n            onload(xhr.response);\n            return;\n          }\n          onerror();\n        };\n        xhr.onerror = onerror;\n        xhr.send(null);\n      };\n    }\n    setWindowTitle = title => (document.title = title);\n  } else {\n  }\n\n  var out = Module.print || console.log.bind(console);\n\n  var err = Module.printErr || console.warn.bind(console);\n\n  Object.assign(Module, moduleOverrides);\n\n  moduleOverrides = null;\n\n  if (Module.arguments) {\n    arguments_ = Module.arguments;\n  }\n\n  if (Module.thisProgram) {\n    thisProgram = Module.thisProgram;\n  }\n\n  if (Module.quit) {\n    quit_ = Module.quit;\n  }\n\n  var tempRet0 = 0;\n\n  var setTempRet0 = value => {\n    tempRet0 = value;\n  };\n\n  var wasmBinary;\n\n  if (Module.wasmBinary) {\n    wasmBinary = Module.wasmBinary;\n  }\n\n  var noExitRuntime = Module.noExitRuntime || true;\n\n  if (typeof WebAssembly != "object") {\n    abort("no native wasm support detected");\n  }\n\n  function setValue(ptr, value, type = "i8", noSafe) {\n    if (type.charAt(type.length - 1) === "*") {\n      type = "i32";\n    }\n    switch (type) {\n      case "i1":\n        HEAP8[ptr >> 0] = value;\n        break;\n\n      case "i8":\n        HEAP8[ptr >> 0] = value;\n        break;\n\n      case "i16":\n        HEAP16[ptr >> 1] = value;\n        break;\n\n      case "i32":\n        HEAP32[ptr >> 2] = value;\n        break;\n\n      case "i64":\n        ((tempI64 = [\n          value >>> 0,\n          ((tempDouble = value),\n          +Math.abs(tempDouble) >= 1\n            ? tempDouble > 0\n              ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) |\n                  0) >>>\n                0\n              : ~~+Math.ceil(\n                  (tempDouble - +(~~tempDouble >>> 0)) / 4294967296\n                ) >>> 0\n            : 0),\n        ]),\n          (HEAP32[ptr >> 2] = tempI64[0]),\n          (HEAP32[(ptr + 4) >> 2] = tempI64[1]));\n        break;\n\n      case "float":\n        HEAPF32[ptr >> 2] = value;\n        break;\n\n      case "double":\n        HEAPF64[ptr >> 3] = value;\n        break;\n\n      default:\n        abort("invalid type for setValue: " + type);\n    }\n  }\n\n  var wasmMemory;\n\n  var ABORT = false;\n\n  var EXITSTATUS;\n\n  function assert(condition, text) {\n    if (!condition) {\n      abort(text);\n    }\n  }\n\n  var UTF8Decoder =\n    typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : undefined;\n\n  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\n    var endIdx = idx + maxBytesToRead;\n    var endPtr = idx;\n    while (heapOrArray[endPtr] && !(endPtr >= endIdx)) {\n      ++endPtr;\n    }\n    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n    }\n    var str = "";\n    while (idx < endPtr) {\n      var u0 = heapOrArray[idx++];\n      if (!(u0 & 128)) {\n        str += String.fromCharCode(u0);\n        continue;\n      }\n      var u1 = heapOrArray[idx++] & 63;\n      if ((u0 & 224) == 192) {\n        str += String.fromCharCode(((u0 & 31) << 6) | u1);\n        continue;\n      }\n      var u2 = heapOrArray[idx++] & 63;\n      if ((u0 & 240) == 224) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n      } else {\n        u0 =\n          ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n      }\n      if (u0 < 65536) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 65536;\n        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\n      }\n    }\n\n    return str;\n  }\n\n  function UTF8ToString(ptr, maxBytesToRead) {\n    return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";\n  }\n\n  function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n    if (!(maxBytesToWrite > 0)) {\n      return 0;\n    }\n    var startIdx = outIdx;\n    var endIdx = outIdx + maxBytesToWrite - 1;\n    for (var i = 0; i < str.length; ++i) {\n      var u = str.charCodeAt(i);\n      if (u >= 55296 && u <= 57343) {\n        var u1 = str.charCodeAt(++i);\n        u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);\n      }\n      if (u <= 127) {\n        if (outIdx >= endIdx) {\n          break;\n        }\n        heap[outIdx++] = u;\n      } else if (u <= 2047) {\n        if (outIdx + 1 >= endIdx) {\n          break;\n        }\n        heap[outIdx++] = 192 | (u >> 6);\n        heap[outIdx++] = 128 | (u & 63);\n      } else if (u <= 65535) {\n        if (outIdx + 2 >= endIdx) {\n          break;\n        }\n        heap[outIdx++] = 224 | (u >> 12);\n        heap[outIdx++] = 128 | ((u >> 6) & 63);\n        heap[outIdx++] = 128 | (u & 63);\n      } else {\n        if (outIdx + 3 >= endIdx) {\n          break;\n        }\n        heap[outIdx++] = 240 | (u >> 18);\n        heap[outIdx++] = 128 | ((u >> 12) & 63);\n        heap[outIdx++] = 128 | ((u >> 6) & 63);\n        heap[outIdx++] = 128 | (u & 63);\n      }\n    }\n    heap[outIdx] = 0;\n    return outIdx - startIdx;\n  }\n\n  function stringToUTF8(str, outPtr, maxBytesToWrite) {\n    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n  }\n\n  function lengthBytesUTF8(str) {\n    var len = 0;\n    for (var i = 0; i < str.length; ++i) {\n      var u = str.charCodeAt(i);\n      if (u >= 55296 && u <= 57343) {\n        u = (65536 + ((u & 1023) << 10)) | (str.charCodeAt(++i) & 1023);\n      }\n      if (u <= 127) {\n        ++len;\n      } else if (u <= 2047) {\n        len += 2;\n      } else if (u <= 65535) {\n        len += 3;\n      } else {\n        len += 4;\n      }\n    }\n    return len;\n  }\n\n  var UTF16Decoder =\n    typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : undefined;\n\n  function UTF16ToString(ptr, maxBytesToRead) {\n    var endPtr = ptr;\n    var idx = endPtr >> 1;\n    var maxIdx = idx + maxBytesToRead / 2;\n    while (!(idx >= maxIdx) && HEAPU16[idx]) {\n      ++idx;\n    }\n    endPtr = idx << 1;\n    if (endPtr - ptr > 32 && UTF16Decoder) {\n      return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n    }\n    var str = "";\n    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n      var codeUnit = HEAP16[(ptr + i * 2) >> 1];\n      if (codeUnit == 0) {\n        break;\n      }\n      str += String.fromCharCode(codeUnit);\n    }\n    return str;\n  }\n\n  function stringToUTF16(str, outPtr, maxBytesToWrite) {\n    if (maxBytesToWrite === undefined) {\n      maxBytesToWrite = 2147483647;\n    }\n    if (maxBytesToWrite < 2) {\n      return 0;\n    }\n    maxBytesToWrite -= 2;\n    var startPtr = outPtr;\n    var numCharsToWrite =\n      maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n    for (var i = 0; i < numCharsToWrite; ++i) {\n      var codeUnit = str.charCodeAt(i);\n      HEAP16[outPtr >> 1] = codeUnit;\n      outPtr += 2;\n    }\n    HEAP16[outPtr >> 1] = 0;\n    return outPtr - startPtr;\n  }\n\n  function lengthBytesUTF16(str) {\n    return str.length * 2;\n  }\n\n  function UTF32ToString(ptr, maxBytesToRead) {\n    var i = 0;\n    var str = "";\n    while (!(i >= maxBytesToRead / 4)) {\n      var utf32 = HEAP32[(ptr + i * 4) >> 2];\n      if (utf32 == 0) {\n        break;\n      }\n      ++i;\n      if (utf32 >= 65536) {\n        var ch = utf32 - 65536;\n        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\n      } else {\n        str += String.fromCharCode(utf32);\n      }\n    }\n    return str;\n  }\n\n  function stringToUTF32(str, outPtr, maxBytesToWrite) {\n    if (maxBytesToWrite === undefined) {\n      maxBytesToWrite = 2147483647;\n    }\n    if (maxBytesToWrite < 4) {\n      return 0;\n    }\n    var startPtr = outPtr;\n    var endPtr = startPtr + maxBytesToWrite - 4;\n    for (var i = 0; i < str.length; ++i) {\n      var codeUnit = str.charCodeAt(i);\n      if (codeUnit >= 55296 && codeUnit <= 57343) {\n        var trailSurrogate = str.charCodeAt(++i);\n        codeUnit =\n          (65536 + ((codeUnit & 1023) << 10)) | (trailSurrogate & 1023);\n      }\n      HEAP32[outPtr >> 2] = codeUnit;\n      outPtr += 4;\n      if (outPtr + 4 > endPtr) {\n        break;\n      }\n    }\n    HEAP32[outPtr >> 2] = 0;\n    return outPtr - startPtr;\n  }\n\n  function lengthBytesUTF32(str) {\n    var len = 0;\n    for (var i = 0; i < str.length; ++i) {\n      var codeUnit = str.charCodeAt(i);\n      if (codeUnit >= 55296 && codeUnit <= 57343) {\n        ++i;\n      }\n      len += 4;\n    }\n    return len;\n  }\n\n  function allocateUTF8(str) {\n    var size = lengthBytesUTF8(str) + 1;\n    var ret = _malloc(size);\n    if (ret) {\n      stringToUTF8Array(str, HEAP8, ret, size);\n    }\n    return ret;\n  }\n\n  function writeArrayToMemory(array, buffer) {\n    HEAP8.set(array, buffer);\n  }\n\n  function writeAsciiToMemory(str, buffer, dontAddNull) {\n    for (var i = 0; i < str.length; ++i) {\n      HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n    }\n    if (!dontAddNull) {\n      HEAP8[buffer >> 0] = 0;\n    }\n  }\n\n  var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n\n  function updateGlobalBufferAndViews(buf) {\n    const mb = (buf.byteLength / 1_000_000).toFixed();\n    Module.print(`Growing wasm buffer to ${mb}MB (${buf.byteLength} bytes).`);\n\n    buffer = buf;\n    Module.HEAP8 = HEAP8 = new Int8Array(buf);\n    Module.HEAP16 = HEAP16 = new Int16Array(buf);\n    Module.HEAP32 = HEAP32 = new Int32Array(buf);\n    Module.HEAPU8 = HEAPU8 = new Uint8Array(buf);\n    Module.HEAPU16 = HEAPU16 = new Uint16Array(buf);\n    Module.HEAPU32 = HEAPU32 = new Uint32Array(buf);\n    Module.HEAPF32 = HEAPF32 = new Float32Array(buf);\n    Module.HEAPF64 = HEAPF64 = new Float64Array(buf);\n  }\n\n  var INITIAL_MEMORY = Module.INITIAL_MEMORY || 16777216;\n\n  if (Module.wasmMemory) {\n    wasmMemory = Module.wasmMemory;\n  } else {\n    wasmMemory = new WebAssembly.Memory({\n      initial: INITIAL_MEMORY / 65536,\n      maximum: 2147483648 / 65536,\n    });\n  }\n\n  if (wasmMemory) {\n    buffer = wasmMemory.buffer;\n  }\n\n  INITIAL_MEMORY = buffer.byteLength;\n\n  updateGlobalBufferAndViews(buffer);\n\n  var wasmTable;\n\n  var __ATPRERUN__ = [];\n\n  var __ATINIT__ = [];\n\n  var __ATPOSTRUN__ = [];\n\n  var runtimeInitialized = false;\n\n  function keepRuntimeAlive() {\n    return noExitRuntime;\n  }\n\n  function preRun() {\n    if (Module.preRun) {\n      if (typeof Module.preRun == "function") {\n        Module.preRun = [Module.preRun];\n      }\n      while (Module.preRun.length) {\n        addOnPreRun(Module.preRun.shift());\n      }\n    }\n    callRuntimeCallbacks(__ATPRERUN__);\n  }\n\n  function initRuntime() {\n    runtimeInitialized = true;\n    callRuntimeCallbacks(__ATINIT__);\n  }\n\n  function postRun() {\n    if (Module.postRun) {\n      if (typeof Module.postRun == "function") {\n        Module.postRun = [Module.postRun];\n      }\n      while (Module.postRun.length) {\n        addOnPostRun(Module.postRun.shift());\n      }\n    }\n    callRuntimeCallbacks(__ATPOSTRUN__);\n  }\n\n  function addOnPreRun(cb) {\n    __ATPRERUN__.unshift(cb);\n  }\n\n  function addOnInit(cb) {\n    __ATINIT__.unshift(cb);\n  }\n\n  function addOnPostRun(cb) {\n    __ATPOSTRUN__.unshift(cb);\n  }\n\n  var runDependencies = 0;\n\n  var runDependencyWatcher = null;\n\n  var dependenciesFulfilled = null;\n\n  function addRunDependency(id) {\n    runDependencies++;\n    if (Module.monitorRunDependencies) {\n      Module.monitorRunDependencies(runDependencies);\n    }\n  }\n\n  function removeRunDependency(id) {\n    runDependencies--;\n    if (Module.monitorRunDependencies) {\n      Module.monitorRunDependencies(runDependencies);\n    }\n    if (runDependencies == 0) {\n      if (runDependencyWatcher !== null) {\n        clearInterval(runDependencyWatcher);\n        runDependencyWatcher = null;\n      }\n      if (dependenciesFulfilled) {\n        var callback = dependenciesFulfilled;\n        dependenciesFulfilled = null;\n        callback();\n      }\n    }\n  }\n\n  Module.preloadedImages = {};\n\n  Module.preloadedAudios = {};\n\n  function abort(what) {\n    {\n      if (Module.onAbort) {\n        Module.onAbort(what);\n      }\n    }\n    what = "Aborted(" + what + ")";\n    err(what);\n    ABORT = true;\n    EXITSTATUS = 1;\n    what += ". Build with -s ASSERTIONS=1 for more info.";\n    var e = new WebAssembly.RuntimeError(what);\n    throw e;\n  }\n\n  var dataURIPrefix = "data:application/octet-stream;base64,";\n\n  function isDataURI(filename) {\n    return filename.startsWith(dataURIPrefix);\n  }\n\n  var wasmBinaryFile;\n\n  wasmBinaryFile = "bergamot-translator.wasm";\n\n  if (!isDataURI(wasmBinaryFile)) {\n    wasmBinaryFile = locateFile(wasmBinaryFile);\n  }\n\n  function getBinary(file) {\n    try {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      if (readBinary) {\n        return readBinary(file);\n      }\n      throw "both async and sync fetching of the wasm failed";\n    } catch (err) {\n      abort(err);\n    }\n  }\n\n  function getBinaryPromise() {\n    if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n      if (typeof fetch == "function") {\n        return fetch(wasmBinaryFile, {\n          credentials: "same-origin",\n        })\n          .then(function (response) {\n            if (!response.ok) {\n              throw (\n                "failed to load wasm binary file at \'" + wasmBinaryFile + "\'"\n              );\n            }\n            return response.arrayBuffer();\n          })\n          .catch(function () {\n            return getBinary(wasmBinaryFile);\n          });\n      }\n    }\n    return Promise.resolve().then(function () {\n      return getBinary(wasmBinaryFile);\n    });\n  }\n\n  function createWasm() {\n    var info = {\n      env: asmLibraryArg,\n      wasm_gemm: createWasmGemm(),\n      wasi_snapshot_preview1: asmLibraryArg,\n    };\n    function receiveInstance(instance, module) {\n      var exports = instance.exports;\n      Module.asm = exports;\n      wasmTable = Module.asm.__indirect_function_table;\n      addOnInit(Module.asm.__wasm_call_ctors);\n      exportAsmFunctions(exports);\n      removeRunDependency("wasm-instantiate");\n    }\n    addRunDependency("wasm-instantiate");\n    function receiveInstantiationResult(result) {\n      receiveInstance(result.instance);\n    }\n    function instantiateArrayBuffer(receiver) {\n      // This function has been patched from the original version.\n      // See Bug 1988289.\n      return getBinaryPromise()\n        .then(binary => {\n          const module = new WebAssembly.Module(binary);\n          const instance = new WebAssembly.Instance(module, info);\n          return { module, instance };\n        })\n        .then(function (instance) {\n          return instance;\n        })\n        .then(receiver, function (reason) {\n          err("failed to asynchronously prepare wasm: " + reason);\n          abort(reason);\n        });\n    }\n    function instantiateAsync() {\n      if (\n        !wasmBinary &&\n        typeof WebAssembly.instantiateStreaming == "function" &&\n        !isDataURI(wasmBinaryFile) &&\n        typeof fetch == "function"\n      ) {\n        return fetch(wasmBinaryFile, {\n          credentials: "same-origin",\n        }).then(function (response) {\n          var result = WebAssembly.instantiateStreaming(response, info);\n          return result.then(receiveInstantiationResult, function (reason) {\n            err("wasm streaming compile failed: " + reason);\n            err("falling back to ArrayBuffer instantiation");\n            return instantiateArrayBuffer(receiveInstantiationResult);\n          });\n        });\n      }\n      return instantiateArrayBuffer(receiveInstantiationResult);\n    }\n    if (Module.instantiateWasm) {\n      try {\n        var exports = Module.instantiateWasm(info, receiveInstance);\n        return exports;\n      } catch (e) {\n        err("Module.instantiateWasm callback failed with error: " + e);\n        return false;\n      }\n    }\n    instantiateAsync();\n    return {};\n  }\n\n  var tempDouble;\n\n  var tempI64;\n\n  var ASM_CONSTS = {\n    1427332($0, $1, $2, $3, $4) {\n      if (!Module.getOrCreateSentenceSegmenter) {\n        Module.getOrCreateSentenceSegmenter = (function () {\n          let segmenters = new Map();\n          return function (lang) {\n            let segmenter = segmenters.get(lang);\n            if (!segmenter) {\n              segmenter = new Intl.Segmenter(lang, {\n                granularity: "sentence",\n              });\n              segmenters.set(lang, segmenter);\n            }\n            return segmenter;\n          };\n        })();\n      }\n      const inputUTF16 = UTF8ToString($0);\n      const lang = UTF8ToString($1);\n      const segmenter = Module.getOrCreateSentenceSegmenter(lang);\n      const sentencesUTF16 = Array.from(segmenter.segment(inputUTF16));\n      const sentenceCount = sentencesUTF16.length;\n      const bytesPerInt = 4;\n      const startsPtr = _malloc(sentenceCount * bytesPerInt);\n      const endsPtr = _malloc(sentenceCount * bytesPerInt);\n      if (!startsPtr || !endsPtr) {\n        throw new Error("Failed to allocate WASM memory for segmentation.");\n      }\n      let sentenceEndUTF8 = 0;\n      sentencesUTF16.forEach(({ segment: sentenceUTF16 }, index) => {\n        const sentenceStartUTF8 = sentenceEndUTF8;\n        sentenceEndUTF8 += lengthBytesUTF8(sentenceUTF16);\n        setValue(startsPtr + index * bytesPerInt, sentenceStartUTF8, "i32");\n        setValue(endsPtr + index * bytesPerInt, sentenceEndUTF8, "i32");\n      });\n      setValue($2, sentenceCount, "i32");\n      setValue($3, startsPtr, "i32");\n      setValue($4, endsPtr, "i32");\n    },\n  };\n\n  function callRuntimeCallbacks(callbacks) {\n    while (callbacks.length) {\n      var callback = callbacks.shift();\n      if (typeof callback == "function") {\n        callback(Module);\n        continue;\n      }\n      var func = callback.func;\n      if (typeof func == "number") {\n        if (callback.arg === undefined) {\n          getWasmTableEntry(func)();\n        } else {\n          getWasmTableEntry(func)(callback.arg);\n        }\n      } else {\n        func(callback.arg === undefined ? null : callback.arg);\n      }\n    }\n  }\n\n  function asmjsMangle(x) {\n    var unmangledSymbols = ["stackAlloc", "stackSave", "stackRestore"];\n    return x.indexOf("dynCall_") == 0 || unmangledSymbols.includes(x)\n      ? x\n      : "_" + x;\n  }\n\n  function exportAsmFunctions(asm) {\n    var global_object = this;\n    for (var __exportedFunc in asm) {\n      var jsname = asmjsMangle(__exportedFunc);\n      global_object[jsname] = Module[jsname] = asm[__exportedFunc];\n    }\n  }\n\n  var wasmTableMirror = [];\n\n  function getWasmTableEntry(funcPtr) {\n    var func = wasmTableMirror[funcPtr];\n    if (!func) {\n      if (funcPtr >= wasmTableMirror.length) {\n        wasmTableMirror.length = funcPtr + 1;\n      }\n      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n    }\n    return func;\n  }\n\n  function ___assert_fail(condition, filename, line, func) {\n    abort(\n      "Assertion failed: " +\n        UTF8ToString(condition) +\n        ", at: " +\n        [\n          filename ? UTF8ToString(filename) : "unknown filename",\n          line,\n          func ? UTF8ToString(func) : "unknown function",\n        ]\n    );\n  }\n\n  function ___cxa_allocate_exception(size) {\n    return _malloc(size + 16) + 16;\n  }\n\n  var exceptionCaught = [];\n\n  var exceptionLast = 0;\n\n  var uncaughtExceptionCount = 0;\n\n  function ___cxa_rethrow() {\n    var catchInfo = exceptionCaught.pop();\n    if (!catchInfo) {\n      abort("no exception to throw");\n    }\n    var info = catchInfo.get_exception_info();\n    var ptr = catchInfo.get_base_ptr();\n    if (!info.get_rethrown()) {\n      exceptionCaught.push(catchInfo);\n      info.set_rethrown(true);\n      info.set_caught(false);\n      uncaughtExceptionCount++;\n    } else {\n      catchInfo.free();\n    }\n    exceptionLast = ptr;\n    throw ptr;\n  }\n\n  function ExceptionInfo(excPtr) {\n    this.excPtr = excPtr;\n    this.ptr = excPtr - 16;\n    this.set_type = function (type) {\n      HEAP32[(this.ptr + 4) >> 2] = type;\n    };\n    this.get_type = function () {\n      return HEAP32[(this.ptr + 4) >> 2];\n    };\n    this.set_destructor = function (destructor) {\n      HEAP32[(this.ptr + 8) >> 2] = destructor;\n    };\n    this.get_destructor = function () {\n      return HEAP32[(this.ptr + 8) >> 2];\n    };\n    this.set_refcount = function (refcount) {\n      HEAP32[this.ptr >> 2] = refcount;\n    };\n    this.set_caught = function (caught) {\n      caught = caught ? 1 : 0;\n      HEAP8[(this.ptr + 12) >> 0] = caught;\n    };\n    this.get_caught = function () {\n      return HEAP8[(this.ptr + 12) >> 0] != 0;\n    };\n    this.set_rethrown = function (rethrown) {\n      rethrown = rethrown ? 1 : 0;\n      HEAP8[(this.ptr + 13) >> 0] = rethrown;\n    };\n    this.get_rethrown = function () {\n      return HEAP8[(this.ptr + 13) >> 0] != 0;\n    };\n    this.init = function (type, destructor) {\n      this.set_type(type);\n      this.set_destructor(destructor);\n      this.set_refcount(0);\n      this.set_caught(false);\n      this.set_rethrown(false);\n    };\n    this.add_ref = function () {\n      var value = HEAP32[this.ptr >> 2];\n      HEAP32[this.ptr >> 2] = value + 1;\n    };\n    this.release_ref = function () {\n      var prev = HEAP32[this.ptr >> 2];\n      HEAP32[this.ptr >> 2] = prev - 1;\n      return prev === 1;\n    };\n  }\n\n  function ___cxa_throw(ptr, type, destructor) {\n    var info = new ExceptionInfo(ptr);\n    info.init(type, destructor);\n    exceptionLast = ptr;\n    uncaughtExceptionCount++;\n    throw ptr;\n  }\n\n  var SYSCALLS = {\n    buffers: [null, [], []],\n    printChar(stream, curr) {\n      var buffer = SYSCALLS.buffers[stream];\n      if (curr === 0 || curr === 10) {\n        (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n        buffer.length = 0;\n      } else {\n        buffer.push(curr);\n      }\n    },\n    varargs: undefined,\n    get() {\n      SYSCALLS.varargs += 4;\n      var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2];\n      return ret;\n    },\n    getStr(ptr) {\n      var ret = UTF8ToString(ptr);\n      return ret;\n    },\n    get64(low, high) {\n      return low;\n    },\n  };\n\n  function ___syscall_faccessat(dirfd, path, amode, flags) {\n    path = SYSCALLS.getStr(path);\n    path = SYSCALLS.calculateAt(dirfd, path);\n    return SYSCALLS.doAccess(path, amode);\n  }\n\n  function ___syscall_fcntl64(fd, cmd, varargs) {\n    SYSCALLS.varargs = varargs;\n    return 0;\n  }\n\n  function ___syscall_fstat64(fd, buf) {}\n\n  function ___syscall_getcwd(buf, size) {}\n\n  function ___syscall_ioctl(fd, op, varargs) {\n    SYSCALLS.varargs = varargs;\n    return 0;\n  }\n\n  function ___syscall_lstat64(path, buf) {}\n\n  function ___syscall_newfstatat(dirfd, path, buf, flags) {}\n\n  function ___syscall_openat(dirfd, path, flags, varargs) {\n    SYSCALLS.varargs = varargs;\n  }\n\n  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {}\n\n  function ___syscall_rmdir(path) {}\n\n  function ___syscall_stat64(path, buf) {}\n\n  function ___syscall_unlinkat(dirfd, path, flags) {}\n\n  var structRegistrations = {};\n\n  function runDestructors(destructors) {\n    while (destructors.length) {\n      var ptr = destructors.pop();\n      var del = destructors.pop();\n      del(ptr);\n    }\n  }\n\n  function simpleReadValueFromPointer(pointer) {\n    return this.fromWireType(HEAPU32[pointer >> 2]);\n  }\n\n  var awaitingDependencies = {};\n\n  var registeredTypes = {};\n\n  var typeDependencies = {};\n\n  var char_0 = 48;\n\n  var char_9 = 57;\n\n  function makeLegalFunctionName(name) {\n    if (undefined === name) {\n      return "_unknown";\n    }\n    name = name.replace(/[^a-zA-Z0-9_]/g, "$");\n    var f = name.charCodeAt(0);\n    if (f >= char_0 && f <= char_9) {\n      return "_" + name;\n    }\n    return name;\n  }\n\n  function createNamedFunction(name, body) {\n    name = makeLegalFunctionName(name);\n    return function () {\n      null;\n      return body.apply(this, arguments);\n    };\n  }\n\n  function extendError(baseErrorType, errorName) {\n    var errorClass = createNamedFunction(errorName, function (message) {\n      this.name = errorName;\n      this.message = message;\n      var stack = new Error(message).stack;\n      if (stack !== undefined) {\n        this.stack =\n          this.toString() + "\\n" + stack.replace(/^Error(:[^\\n]*)?\\n/, "");\n      }\n    });\n    errorClass.prototype = Object.create(baseErrorType.prototype);\n    errorClass.prototype.constructor = errorClass;\n    errorClass.prototype.toString = function () {\n      if (this.message === undefined) {\n        return this.name;\n      }\n      return this.name + ": " + this.message;\n    };\n    return errorClass;\n  }\n\n  var InternalError = undefined;\n\n  function throwInternalError(message) {\n    throw new InternalError(message);\n  }\n\n  function whenDependentTypesAreResolved(\n    myTypes,\n    dependentTypes,\n    getTypeConverters\n  ) {\n    myTypes.forEach(function (type) {\n      typeDependencies[type] = dependentTypes;\n    });\n    function onComplete(typeConverters) {\n      var myTypeConverters = getTypeConverters(typeConverters);\n      if (myTypeConverters.length !== myTypes.length) {\n        throwInternalError("Mismatched type converter count");\n      }\n      for (var i = 0; i < myTypes.length; ++i) {\n        registerType(myTypes[i], myTypeConverters[i]);\n      }\n    }\n    var typeConverters = new Array(dependentTypes.length);\n    var unregisteredTypes = [];\n    var registered = 0;\n    dependentTypes.forEach((dt, i) => {\n      if (registeredTypes.hasOwnProperty(dt)) {\n        typeConverters[i] = registeredTypes[dt];\n      } else {\n        unregisteredTypes.push(dt);\n        if (!awaitingDependencies.hasOwnProperty(dt)) {\n          awaitingDependencies[dt] = [];\n        }\n        awaitingDependencies[dt].push(() => {\n          typeConverters[i] = registeredTypes[dt];\n          ++registered;\n          if (registered === unregisteredTypes.length) {\n            onComplete(typeConverters);\n          }\n        });\n      }\n    });\n    if (0 === unregisteredTypes.length) {\n      onComplete(typeConverters);\n    }\n  }\n\n  function __embind_finalize_value_object(structType) {\n    var reg = structRegistrations[structType];\n    delete structRegistrations[structType];\n    var rawConstructor = reg.rawConstructor;\n    var rawDestructor = reg.rawDestructor;\n    var fieldRecords = reg.fields;\n    var fieldTypes = fieldRecords\n      .map(field => field.getterReturnType)\n      .concat(fieldRecords.map(field => field.setterArgumentType));\n    whenDependentTypesAreResolved([structType], fieldTypes, fieldTypes => {\n      var fields = {};\n      fieldRecords.forEach((field, i) => {\n        var fieldName = field.fieldName;\n        var getterReturnType = fieldTypes[i];\n        var getter = field.getter;\n        var getterContext = field.getterContext;\n        var setterArgumentType = fieldTypes[i + fieldRecords.length];\n        var setter = field.setter;\n        var setterContext = field.setterContext;\n        fields[fieldName] = {\n          read: ptr => {\n            return getterReturnType.fromWireType(getter(getterContext, ptr));\n          },\n          write: (ptr, o) => {\n            var destructors = [];\n            setter(\n              setterContext,\n              ptr,\n              setterArgumentType.toWireType(destructors, o)\n            );\n            runDestructors(destructors);\n          },\n        };\n      });\n      return [\n        {\n          name: reg.name,\n          fromWireType: function (ptr) {\n            var rv = {};\n            for (var i in fields) {\n              rv[i] = fields[i].read(ptr);\n            }\n            rawDestructor(ptr);\n            return rv;\n          },\n          toWireType: function (destructors, o) {\n            for (var fieldName in fields) {\n              if (!(fieldName in o)) {\n                throw new TypeError(\'Missing field:  "\' + fieldName + \'"\');\n              }\n            }\n            var ptr = rawConstructor();\n            for (fieldName in fields) {\n              fields[fieldName].write(ptr, o[fieldName]);\n            }\n            if (destructors !== null) {\n              destructors.push(rawDestructor, ptr);\n            }\n            return ptr;\n          },\n          argPackAdvance: 8,\n          readValueFromPointer: simpleReadValueFromPointer,\n          destructorFunction: rawDestructor,\n        },\n      ];\n    });\n  }\n\n  function __embind_register_bigint(\n    primitiveType,\n    name,\n    size,\n    minRange,\n    maxRange\n  ) {}\n\n  function getShiftFromSize(size) {\n    switch (size) {\n      case 1:\n        return 0;\n\n      case 2:\n        return 1;\n\n      case 4:\n        return 2;\n\n      case 8:\n        return 3;\n\n      default:\n        throw new TypeError("Unknown type size: " + size);\n    }\n  }\n\n  function embind_init_charCodes() {\n    var codes = new Array(256);\n    for (var i = 0; i < 256; ++i) {\n      codes[i] = String.fromCharCode(i);\n    }\n    embind_charCodes = codes;\n  }\n\n  var embind_charCodes = undefined;\n\n  function readLatin1String(ptr) {\n    var ret = "";\n    var c = ptr;\n    while (HEAPU8[c]) {\n      ret += embind_charCodes[HEAPU8[c++]];\n    }\n    return ret;\n  }\n\n  var BindingError = undefined;\n\n  function throwBindingError(message) {\n    throw new BindingError(message);\n  }\n\n  function registerType(rawType, registeredInstance, options = {}) {\n    if (!("argPackAdvance" in registeredInstance)) {\n      throw new TypeError(\n        "registerType registeredInstance requires argPackAdvance"\n      );\n    }\n    var name = registeredInstance.name;\n    if (!rawType) {\n      throwBindingError(\n        \'type "\' + name + \'" must have a positive integer typeid pointer\'\n      );\n    }\n    if (registeredTypes.hasOwnProperty(rawType)) {\n      if (options.ignoreDuplicateRegistrations) {\n        return;\n      }\n      throwBindingError("Cannot register type \'" + name + "\' twice");\n    }\n    registeredTypes[rawType] = registeredInstance;\n    delete typeDependencies[rawType];\n    if (awaitingDependencies.hasOwnProperty(rawType)) {\n      var callbacks = awaitingDependencies[rawType];\n      delete awaitingDependencies[rawType];\n      callbacks.forEach(cb => cb());\n    }\n  }\n\n  function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n    var shift = getShiftFromSize(size);\n    name = readLatin1String(name);\n    registerType(rawType, {\n      name,\n      fromWireType: function (wt) {\n        return !!wt;\n      },\n      toWireType: function (destructors, o) {\n        return o ? trueValue : falseValue;\n      },\n      argPackAdvance: 8,\n      readValueFromPointer: function (pointer) {\n        var heap;\n        if (size === 1) {\n          heap = HEAP8;\n        } else if (size === 2) {\n          heap = HEAP16;\n        } else if (size === 4) {\n          heap = HEAP32;\n        } else {\n          throw new TypeError("Unknown boolean type size: " + name);\n        }\n        return this.fromWireType(heap[pointer >> shift]);\n      },\n      destructorFunction: null,\n    });\n  }\n\n  function ClassHandle_isAliasOf(other) {\n    if (!(this instanceof ClassHandle)) {\n      return false;\n    }\n    if (!(other instanceof ClassHandle)) {\n      return false;\n    }\n    var leftClass = this.$$.ptrType.registeredClass;\n    var left = this.$$.ptr;\n    var rightClass = other.$$.ptrType.registeredClass;\n    var right = other.$$.ptr;\n    while (leftClass.baseClass) {\n      left = leftClass.upcast(left);\n      leftClass = leftClass.baseClass;\n    }\n    while (rightClass.baseClass) {\n      right = rightClass.upcast(right);\n      rightClass = rightClass.baseClass;\n    }\n    return leftClass === rightClass && left === right;\n  }\n\n  function shallowCopyInternalPointer(o) {\n    return {\n      count: o.count,\n      deleteScheduled: o.deleteScheduled,\n      preservePointerOnDelete: o.preservePointerOnDelete,\n      ptr: o.ptr,\n      ptrType: o.ptrType,\n      smartPtr: o.smartPtr,\n      smartPtrType: o.smartPtrType,\n    };\n  }\n\n  function throwInstanceAlreadyDeleted(obj) {\n    function getInstanceTypeName(handle) {\n      return handle.$$.ptrType.registeredClass.name;\n    }\n    throwBindingError(getInstanceTypeName(obj) + " instance already deleted");\n  }\n\n  var finalizationRegistry = false;\n\n  function detachFinalizer(handle) {}\n\n  function runDestructor($$) {\n    if ($$.smartPtr) {\n      $$.smartPtrType.rawDestructor($$.smartPtr);\n    } else {\n      $$.ptrType.registeredClass.rawDestructor($$.ptr);\n    }\n  }\n\n  function releaseClassHandle($$) {\n    $$.count.value -= 1;\n    var toDelete = 0 === $$.count.value;\n    if (toDelete) {\n      runDestructor($$);\n    }\n  }\n\n  function downcastPointer(ptr, ptrClass, desiredClass) {\n    if (ptrClass === desiredClass) {\n      return ptr;\n    }\n    if (undefined === desiredClass.baseClass) {\n      return null;\n    }\n    var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n    if (rv === null) {\n      return null;\n    }\n    return desiredClass.downcast(rv);\n  }\n\n  var registeredPointers = {};\n\n  function getInheritedInstanceCount() {\n    return Object.keys(registeredInstances).length;\n  }\n\n  function getLiveInheritedInstances() {\n    var rv = [];\n    for (var k in registeredInstances) {\n      if (registeredInstances.hasOwnProperty(k)) {\n        rv.push(registeredInstances[k]);\n      }\n    }\n    return rv;\n  }\n\n  var deletionQueue = [];\n\n  function flushPendingDeletes() {\n    while (deletionQueue.length) {\n      var obj = deletionQueue.pop();\n      obj.$$.deleteScheduled = false;\n      obj.delete();\n    }\n  }\n\n  var delayFunction = undefined;\n\n  function setDelayFunction(fn) {\n    delayFunction = fn;\n    if (deletionQueue.length && delayFunction) {\n      delayFunction(flushPendingDeletes);\n    }\n  }\n\n  function init_embind() {\n    Module.getInheritedInstanceCount = getInheritedInstanceCount;\n    Module.getLiveInheritedInstances = getLiveInheritedInstances;\n    Module.flushPendingDeletes = flushPendingDeletes;\n    Module.setDelayFunction = setDelayFunction;\n  }\n\n  var registeredInstances = {};\n\n  function getBasestPointer(class_, ptr) {\n    if (ptr === undefined) {\n      throwBindingError("ptr should not be undefined");\n    }\n    while (class_.baseClass) {\n      ptr = class_.upcast(ptr);\n      class_ = class_.baseClass;\n    }\n    return ptr;\n  }\n\n  function getInheritedInstance(class_, ptr) {\n    ptr = getBasestPointer(class_, ptr);\n    return registeredInstances[ptr];\n  }\n\n  function makeClassHandle(prototype, record) {\n    if (!record.ptrType || !record.ptr) {\n      throwInternalError("makeClassHandle requires ptr and ptrType");\n    }\n    var hasSmartPtrType = !!record.smartPtrType;\n    var hasSmartPtr = !!record.smartPtr;\n    if (hasSmartPtrType !== hasSmartPtr) {\n      throwInternalError("Both smartPtrType and smartPtr must be specified");\n    }\n    record.count = {\n      value: 1,\n    };\n    return attachFinalizer(\n      Object.create(prototype, {\n        $$: {\n          value: record,\n        },\n      })\n    );\n  }\n\n  function RegisteredPointer_fromWireType(ptr) {\n    var rawPointer = this.getPointee(ptr);\n    if (!rawPointer) {\n      this.destructor(ptr);\n      return null;\n    }\n    var registeredInstance = getInheritedInstance(\n      this.registeredClass,\n      rawPointer\n    );\n    if (undefined !== registeredInstance) {\n      if (0 === registeredInstance.$$.count.value) {\n        registeredInstance.$$.ptr = rawPointer;\n        registeredInstance.$$.smartPtr = ptr;\n        return registeredInstance.clone();\n      }\n      var rv = registeredInstance.clone();\n      this.destructor(ptr);\n      return rv;\n    }\n    function makeDefaultHandle() {\n      if (this.isSmartPointer) {\n        return makeClassHandle(this.registeredClass.instancePrototype, {\n          ptrType: this.pointeeType,\n          ptr: rawPointer,\n          smartPtrType: this,\n          smartPtr: ptr,\n        });\n      }\n      return makeClassHandle(this.registeredClass.instancePrototype, {\n        ptrType: this,\n        ptr,\n      });\n    }\n    var actualType = this.registeredClass.getActualType(rawPointer);\n    var registeredPointerRecord = registeredPointers[actualType];\n    if (!registeredPointerRecord) {\n      return makeDefaultHandle.call(this);\n    }\n    var toType;\n    if (this.isConst) {\n      toType = registeredPointerRecord.constPointerType;\n    } else {\n      toType = registeredPointerRecord.pointerType;\n    }\n    var dp = downcastPointer(\n      rawPointer,\n      this.registeredClass,\n      toType.registeredClass\n    );\n    if (dp === null) {\n      return makeDefaultHandle.call(this);\n    }\n    if (this.isSmartPointer) {\n      return makeClassHandle(toType.registeredClass.instancePrototype, {\n        ptrType: toType,\n        ptr: dp,\n        smartPtrType: this,\n        smartPtr: ptr,\n      });\n    }\n    return makeClassHandle(toType.registeredClass.instancePrototype, {\n      ptrType: toType,\n      ptr: dp,\n    });\n  }\n\n  function attachFinalizer(handle) {\n    if ("undefined" === typeof FinalizationRegistry) {\n      attachFinalizer = handle => handle;\n      return handle;\n    }\n    finalizationRegistry = new FinalizationRegistry(info => {\n      releaseClassHandle(info.$$);\n    });\n    attachFinalizer = handle => {\n      var $$ = handle.$$;\n      var hasSmartPtr = !!$$.smartPtr;\n      if (hasSmartPtr) {\n        var info = {\n          $$,\n        };\n        finalizationRegistry.register(handle, info, handle);\n      }\n      return handle;\n    };\n    detachFinalizer = handle => finalizationRegistry.unregister(handle);\n    return attachFinalizer(handle);\n  }\n\n  function ClassHandle_clone() {\n    if (!this.$$.ptr) {\n      throwInstanceAlreadyDeleted(this);\n    }\n    if (this.$$.preservePointerOnDelete) {\n      this.$$.count.value += 1;\n      return this;\n    }\n    var clone = attachFinalizer(\n      Object.create(Object.getPrototypeOf(this), {\n        $$: {\n          value: shallowCopyInternalPointer(this.$$),\n        },\n      })\n    );\n    clone.$$.count.value += 1;\n    clone.$$.deleteScheduled = false;\n    return clone;\n  }\n\n  function ClassHandle_delete() {\n    if (!this.$$.ptr) {\n      throwInstanceAlreadyDeleted(this);\n    }\n    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n      throwBindingError("Object already scheduled for deletion");\n    }\n    detachFinalizer(this);\n    releaseClassHandle(this.$$);\n    if (!this.$$.preservePointerOnDelete) {\n      this.$$.smartPtr = undefined;\n      this.$$.ptr = undefined;\n    }\n  }\n\n  function ClassHandle_isDeleted() {\n    return !this.$$.ptr;\n  }\n\n  function ClassHandle_deleteLater() {\n    if (!this.$$.ptr) {\n      throwInstanceAlreadyDeleted(this);\n    }\n    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n      throwBindingError("Object already scheduled for deletion");\n    }\n    deletionQueue.push(this);\n    if (deletionQueue.length === 1 && delayFunction) {\n      delayFunction(flushPendingDeletes);\n    }\n    this.$$.deleteScheduled = true;\n    return this;\n  }\n\n  function init_ClassHandle() {\n    ClassHandle.prototype.isAliasOf = ClassHandle_isAliasOf;\n    ClassHandle.prototype.clone = ClassHandle_clone;\n    ClassHandle.prototype.delete = ClassHandle_delete;\n    ClassHandle.prototype.isDeleted = ClassHandle_isDeleted;\n    ClassHandle.prototype.deleteLater = ClassHandle_deleteLater;\n  }\n\n  function ClassHandle() {}\n\n  function ensureOverloadTable(proto, methodName, humanName) {\n    if (undefined === proto[methodName].overloadTable) {\n      var prevFunc = proto[methodName];\n      proto[methodName] = function () {\n        if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n          throwBindingError(\n            "Function \'" +\n              humanName +\n              "\' called with an invalid number of arguments (" +\n              arguments.length +\n              ") - expects one of (" +\n              proto[methodName].overloadTable +\n              ")!"\n          );\n        }\n        return proto[methodName].overloadTable[arguments.length].apply(\n          this,\n          arguments\n        );\n      };\n      proto[methodName].overloadTable = [];\n      proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n    }\n  }\n\n  function exposePublicSymbol(name, value, numArguments) {\n    if (Module.hasOwnProperty(name)) {\n      if (\n        undefined === numArguments ||\n        (undefined !== Module[name].overloadTable &&\n          undefined !== Module[name].overloadTable[numArguments])\n      ) {\n        throwBindingError("Cannot register public name \'" + name + "\' twice");\n      }\n      ensureOverloadTable(Module, name, name);\n      if (Module.hasOwnProperty(numArguments)) {\n        throwBindingError(\n          "Cannot register multiple overloads of a function with the same number of arguments (" +\n            numArguments +\n            ")!"\n        );\n      }\n      Module[name].overloadTable[numArguments] = value;\n    } else {\n      Module[name] = value;\n      if (undefined !== numArguments) {\n        Module[name].numArguments = numArguments;\n      }\n    }\n  }\n\n  function RegisteredClass(\n    name,\n    constructor,\n    instancePrototype,\n    rawDestructor,\n    baseClass,\n    getActualType,\n    upcast,\n    downcast\n  ) {\n    this.name = name;\n    this.constructor = constructor;\n    this.instancePrototype = instancePrototype;\n    this.rawDestructor = rawDestructor;\n    this.baseClass = baseClass;\n    this.getActualType = getActualType;\n    this.upcast = upcast;\n    this.downcast = downcast;\n    this.pureVirtualFunctions = [];\n  }\n\n  function upcastPointer(ptr, ptrClass, desiredClass) {\n    while (ptrClass !== desiredClass) {\n      if (!ptrClass.upcast) {\n        throwBindingError(\n          "Expected null or instance of " +\n            desiredClass.name +\n            ", got an instance of " +\n            ptrClass.name\n        );\n      }\n      ptr = ptrClass.upcast(ptr);\n      ptrClass = ptrClass.baseClass;\n    }\n    return ptr;\n  }\n\n  function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n    if (handle === null) {\n      if (this.isReference) {\n        throwBindingError("null is not a valid " + this.name);\n      }\n      return 0;\n    }\n    if (!handle.$$) {\n      throwBindingError(\n        \'Cannot pass "\' + _embind_repr(handle) + \'" as a \' + this.name\n      );\n    }\n    if (!handle.$$.ptr) {\n      throwBindingError(\n        "Cannot pass deleted object as a pointer of type " + this.name\n      );\n    }\n    var handleClass = handle.$$.ptrType.registeredClass;\n    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n    return ptr;\n  }\n\n  function genericPointerToWireType(destructors, handle) {\n    var ptr;\n    if (handle === null) {\n      if (this.isReference) {\n        throwBindingError("null is not a valid " + this.name);\n      }\n      if (this.isSmartPointer) {\n        ptr = this.rawConstructor();\n        if (destructors !== null) {\n          destructors.push(this.rawDestructor, ptr);\n        }\n        return ptr;\n      }\n      return 0;\n    }\n    if (!handle.$$) {\n      throwBindingError(\n        \'Cannot pass "\' + _embind_repr(handle) + \'" as a \' + this.name\n      );\n    }\n    if (!handle.$$.ptr) {\n      throwBindingError(\n        "Cannot pass deleted object as a pointer of type " + this.name\n      );\n    }\n    if (!this.isConst && handle.$$.ptrType.isConst) {\n      throwBindingError(\n        "Cannot convert argument of type " +\n          (handle.$$.smartPtrType\n            ? handle.$$.smartPtrType.name\n            : handle.$$.ptrType.name) +\n          " to parameter type " +\n          this.name\n      );\n    }\n    var handleClass = handle.$$.ptrType.registeredClass;\n    ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n    if (this.isSmartPointer) {\n      if (undefined === handle.$$.smartPtr) {\n        throwBindingError("Passing raw pointer to smart pointer is illegal");\n      }\n      switch (this.sharingPolicy) {\n        case 0:\n          if (handle.$$.smartPtrType === this) {\n            ptr = handle.$$.smartPtr;\n          } else {\n            throwBindingError(\n              "Cannot convert argument of type " +\n                (handle.$$.smartPtrType\n                  ? handle.$$.smartPtrType.name\n                  : handle.$$.ptrType.name) +\n                " to parameter type " +\n                this.name\n            );\n          }\n          break;\n\n        case 1:\n          ptr = handle.$$.smartPtr;\n          break;\n\n        case 2:\n          if (handle.$$.smartPtrType === this) {\n            ptr = handle.$$.smartPtr;\n          } else {\n            var clonedHandle = handle.clone();\n            ptr = this.rawShare(\n              ptr,\n              Emval.toHandle(function () {\n                clonedHandle.delete();\n              })\n            );\n            if (destructors !== null) {\n              destructors.push(this.rawDestructor, ptr);\n            }\n          }\n          break;\n\n        default:\n          throwBindingError("Unsupporting sharing policy");\n      }\n    }\n    return ptr;\n  }\n\n  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n    if (handle === null) {\n      if (this.isReference) {\n        throwBindingError("null is not a valid " + this.name);\n      }\n      return 0;\n    }\n    if (!handle.$$) {\n      throwBindingError(\n        \'Cannot pass "\' + _embind_repr(handle) + \'" as a \' + this.name\n      );\n    }\n    if (!handle.$$.ptr) {\n      throwBindingError(\n        "Cannot pass deleted object as a pointer of type " + this.name\n      );\n    }\n    if (handle.$$.ptrType.isConst) {\n      throwBindingError(\n        "Cannot convert argument of type " +\n          handle.$$.ptrType.name +\n          " to parameter type " +\n          this.name\n      );\n    }\n    var handleClass = handle.$$.ptrType.registeredClass;\n    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n    return ptr;\n  }\n\n  function RegisteredPointer_getPointee(ptr) {\n    if (this.rawGetPointee) {\n      ptr = this.rawGetPointee(ptr);\n    }\n    return ptr;\n  }\n\n  function RegisteredPointer_destructor(ptr) {\n    if (this.rawDestructor) {\n      this.rawDestructor(ptr);\n    }\n  }\n\n  function RegisteredPointer_deleteObject(handle) {\n    if (handle !== null) {\n      handle.delete();\n    }\n  }\n\n  function init_RegisteredPointer() {\n    RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n    RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n    RegisteredPointer.prototype.argPackAdvance = 8;\n    RegisteredPointer.prototype.readValueFromPointer =\n      simpleReadValueFromPointer;\n    RegisteredPointer.prototype.deleteObject = RegisteredPointer_deleteObject;\n    RegisteredPointer.prototype.fromWireType = RegisteredPointer_fromWireType;\n  }\n\n  function RegisteredPointer(\n    name,\n    registeredClass,\n    isReference,\n    isConst,\n    isSmartPointer,\n    pointeeType,\n    sharingPolicy,\n    rawGetPointee,\n    rawConstructor,\n    rawShare,\n    rawDestructor\n  ) {\n    this.name = name;\n    this.registeredClass = registeredClass;\n    this.isReference = isReference;\n    this.isConst = isConst;\n    this.isSmartPointer = isSmartPointer;\n    this.pointeeType = pointeeType;\n    this.sharingPolicy = sharingPolicy;\n    this.rawGetPointee = rawGetPointee;\n    this.rawConstructor = rawConstructor;\n    this.rawShare = rawShare;\n    this.rawDestructor = rawDestructor;\n    if (!isSmartPointer && registeredClass.baseClass === undefined) {\n      if (isConst) {\n        this.toWireType = constNoSmartPtrRawPointerToWireType;\n        this.destructorFunction = null;\n      } else {\n        this.toWireType = nonConstNoSmartPtrRawPointerToWireType;\n        this.destructorFunction = null;\n      }\n    } else {\n      this.toWireType = genericPointerToWireType;\n    }\n  }\n\n  function replacePublicSymbol(name, value, numArguments) {\n    if (!Module.hasOwnProperty(name)) {\n      throwInternalError("Replacing nonexistant public symbol");\n    }\n    if (\n      undefined !== Module[name].overloadTable &&\n      undefined !== numArguments\n    ) {\n      Module[name].overloadTable[numArguments] = value;\n    } else {\n      Module[name] = value;\n      Module[name].argCount = numArguments;\n    }\n  }\n\n  function dynCallLegacy(sig, ptr, args) {\n    var f = Module["dynCall_" + sig];\n    return args && args.length\n      ? f.apply(null, [ptr].concat(args))\n      : f.call(null, ptr);\n  }\n\n  function dynCall(sig, ptr, args) {\n    if (sig.includes("j")) {\n      return dynCallLegacy(sig, ptr, args);\n    }\n    return getWasmTableEntry(ptr).apply(null, args);\n  }\n\n  function getDynCaller(sig, ptr) {\n    var argCache = [];\n    return function () {\n      argCache.length = 0;\n      Object.assign(argCache, arguments);\n      return dynCall(sig, ptr, argCache);\n    };\n  }\n\n  function embind__requireFunction(signature, rawFunction) {\n    signature = readLatin1String(signature);\n    function makeDynCaller() {\n      if (signature.includes("j")) {\n        return getDynCaller(signature, rawFunction);\n      }\n      return getWasmTableEntry(rawFunction);\n    }\n    var fp = makeDynCaller();\n    if (typeof fp != "function") {\n      throwBindingError(\n        "unknown function pointer with signature " +\n          signature +\n          ": " +\n          rawFunction\n      );\n    }\n    return fp;\n  }\n\n  var UnboundTypeError = undefined;\n\n  function getTypeName(type) {\n    var ptr = ___getTypeName(type);\n    var rv = readLatin1String(ptr);\n    _free(ptr);\n    return rv;\n  }\n\n  function throwUnboundTypeError(message, types) {\n    var unboundTypes = [];\n    var seen = {};\n    function visit(type) {\n      if (seen[type]) {\n        return;\n      }\n      if (registeredTypes[type]) {\n        return;\n      }\n      if (typeDependencies[type]) {\n        typeDependencies[type].forEach(visit);\n        return;\n      }\n      unboundTypes.push(type);\n      seen[type] = true;\n    }\n    types.forEach(visit);\n    throw new UnboundTypeError(\n      message + ": " + unboundTypes.map(getTypeName).join([", "])\n    );\n  }\n\n  function __embind_register_class(\n    rawType,\n    rawPointerType,\n    rawConstPointerType,\n    baseClassRawType,\n    getActualTypeSignature,\n    getActualType,\n    upcastSignature,\n    upcast,\n    downcastSignature,\n    downcast,\n    name,\n    destructorSignature,\n    rawDestructor\n  ) {\n    name = readLatin1String(name);\n    getActualType = embind__requireFunction(\n      getActualTypeSignature,\n      getActualType\n    );\n    if (upcast) {\n      upcast = embind__requireFunction(upcastSignature, upcast);\n    }\n    if (downcast) {\n      downcast = embind__requireFunction(downcastSignature, downcast);\n    }\n    rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n    var legalFunctionName = makeLegalFunctionName(name);\n    exposePublicSymbol(legalFunctionName, function () {\n      throwUnboundTypeError(\n        "Cannot construct " + name + " due to unbound types",\n        [baseClassRawType]\n      );\n    });\n    whenDependentTypesAreResolved(\n      [rawType, rawPointerType, rawConstPointerType],\n      baseClassRawType ? [baseClassRawType] : [],\n      function (base) {\n        base = base[0];\n        var baseClass;\n        var basePrototype;\n        if (baseClassRawType) {\n          baseClass = base.registeredClass;\n          basePrototype = baseClass.instancePrototype;\n        } else {\n          basePrototype = ClassHandle.prototype;\n        }\n        var constructor = createNamedFunction(legalFunctionName, function () {\n          if (Object.getPrototypeOf(this) !== instancePrototype) {\n            throw new BindingError("Use \'new\' to construct " + name);\n          }\n          if (undefined === registeredClass.constructor_body) {\n            throw new BindingError(name + " has no accessible constructor");\n          }\n          var body = registeredClass.constructor_body[arguments.length];\n          if (undefined === body) {\n            throw new BindingError(\n              "Tried to invoke ctor of " +\n                name +\n                " with invalid number of parameters (" +\n                arguments.length +\n                ") - expected (" +\n                Object.keys(registeredClass.constructor_body).toString() +\n                ") parameters instead!"\n            );\n          }\n          return body.apply(this, arguments);\n        });\n        var instancePrototype = Object.create(basePrototype, {\n          constructor: {\n            value: constructor,\n          },\n        });\n        constructor.prototype = instancePrototype;\n        var registeredClass = new RegisteredClass(\n          name,\n          constructor,\n          instancePrototype,\n          rawDestructor,\n          baseClass,\n          getActualType,\n          upcast,\n          downcast\n        );\n        var referenceConverter = new RegisteredPointer(\n          name,\n          registeredClass,\n          true,\n          false,\n          false\n        );\n        var pointerConverter = new RegisteredPointer(\n          name + "*",\n          registeredClass,\n          false,\n          false,\n          false\n        );\n        var constPointerConverter = new RegisteredPointer(\n          name + " const*",\n          registeredClass,\n          false,\n          true,\n          false\n        );\n        registeredPointers[rawType] = {\n          pointerType: pointerConverter,\n          constPointerType: constPointerConverter,\n        };\n        replacePublicSymbol(legalFunctionName, constructor);\n        return [referenceConverter, pointerConverter, constPointerConverter];\n      }\n    );\n  }\n\n  function heap32VectorToArray(count, firstElement) {\n    var array = [];\n    for (var i = 0; i < count; i++) {\n      array.push(HEAP32[(firstElement >> 2) + i]);\n    }\n    return array;\n  }\n\n  function __embind_register_class_constructor(\n    rawClassType,\n    argCount,\n    rawArgTypesAddr,\n    invokerSignature,\n    invoker,\n    rawConstructor\n  ) {\n    assert(argCount > 0);\n    var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n    invoker = embind__requireFunction(invokerSignature, invoker);\n    whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n      classType = classType[0];\n      var humanName = "constructor " + classType.name;\n      if (undefined === classType.registeredClass.constructor_body) {\n        classType.registeredClass.constructor_body = [];\n      }\n      if (\n        undefined !== classType.registeredClass.constructor_body[argCount - 1]\n      ) {\n        throw new BindingError(\n          "Cannot register multiple constructors with identical number of parameters (" +\n            (argCount - 1) +\n            ") for class \'" +\n            classType.name +\n            "\'! Overload resolution is currently only performed using the parameter count, not actual type info!"\n        );\n      }\n      classType.registeredClass.constructor_body[argCount - 1] = () => {\n        throwUnboundTypeError(\n          "Cannot construct " + classType.name + " due to unbound types",\n          rawArgTypes\n        );\n      };\n      whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n        argTypes.splice(1, 0, null);\n        classType.registeredClass.constructor_body[argCount - 1] =\n          craftInvokerFunction(\n            humanName,\n            argTypes,\n            null,\n            invoker,\n            rawConstructor\n          );\n        return [];\n      });\n      return [];\n    });\n  }\n\n  function craftInvokerFunction(\n    humanName,\n    argTypes,\n    classType,\n    cppInvokerFunc,\n    cppTargetFunc\n  ) {\n    var argCount = argTypes.length;\n    if (argCount < 2) {\n      throwBindingError(\n        "argTypes array size mismatch! Must at least get return value and \'this\' types!"\n      );\n    }\n    var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n    var needsDestructorStack = false;\n    for (var i = 1; i < argTypes.length; ++i) {\n      if (\n        argTypes[i] !== null &&\n        argTypes[i].destructorFunction === undefined\n      ) {\n        needsDestructorStack = true;\n        break;\n      }\n    }\n    var returns = argTypes[0].name !== "void";\n    var expectedArgCount = argCount - 2;\n    var argsWired = new Array(expectedArgCount);\n    var invokerFuncArgs = [];\n    var destructors = [];\n    return function () {\n      if (arguments.length !== expectedArgCount) {\n        throwBindingError(\n          "function " +\n            humanName +\n            " called with " +\n            arguments.length +\n            " arguments, expected " +\n            expectedArgCount +\n            " args!"\n        );\n      }\n      destructors.length = 0;\n      var thisWired;\n      invokerFuncArgs.length = isClassMethodFunc ? 2 : 1;\n      invokerFuncArgs[0] = cppTargetFunc;\n      if (isClassMethodFunc) {\n        thisWired = argTypes[1].toWireType(destructors, this);\n        invokerFuncArgs[1] = thisWired;\n      }\n      for (var i = 0; i < expectedArgCount; ++i) {\n        argsWired[i] = argTypes[i + 2].toWireType(destructors, arguments[i]);\n        invokerFuncArgs.push(argsWired[i]);\n      }\n      var rv = cppInvokerFunc.apply(null, invokerFuncArgs);\n      function onDone(rv) {\n        if (needsDestructorStack) {\n          runDestructors(destructors);\n        } else {\n          for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; i++) {\n            var param = i === 1 ? thisWired : argsWired[i - 2];\n            if (argTypes[i].destructorFunction !== null) {\n              argTypes[i].destructorFunction(param);\n            }\n          }\n        }\n        if (returns) {\n          return argTypes[0].fromWireType(rv);\n        }\n      }\n      return onDone(rv);\n    };\n  }\n\n  function __embind_register_class_function(\n    rawClassType,\n    methodName,\n    argCount,\n    rawArgTypesAddr,\n    invokerSignature,\n    rawInvoker,\n    context,\n    isPureVirtual\n  ) {\n    var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n    methodName = readLatin1String(methodName);\n    rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n    whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n      classType = classType[0];\n      var humanName = classType.name + "." + methodName;\n      if (methodName.startsWith("@@")) {\n        methodName = Symbol[methodName.substring(2)];\n      }\n      if (isPureVirtual) {\n        classType.registeredClass.pureVirtualFunctions.push(methodName);\n      }\n      function unboundTypesHandler() {\n        throwUnboundTypeError(\n          "Cannot call " + humanName + " due to unbound types",\n          rawArgTypes\n        );\n      }\n      var proto = classType.registeredClass.instancePrototype;\n      var method = proto[methodName];\n      if (\n        undefined === method ||\n        (undefined === method.overloadTable &&\n          method.className !== classType.name &&\n          method.argCount === argCount - 2)\n      ) {\n        unboundTypesHandler.argCount = argCount - 2;\n        unboundTypesHandler.className = classType.name;\n        proto[methodName] = unboundTypesHandler;\n      } else {\n        ensureOverloadTable(proto, methodName, humanName);\n        proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n      }\n      whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n        var memberFunction = craftInvokerFunction(\n          humanName,\n          argTypes,\n          classType,\n          rawInvoker,\n          context\n        );\n        if (undefined === proto[methodName].overloadTable) {\n          memberFunction.argCount = argCount - 2;\n          proto[methodName] = memberFunction;\n        } else {\n          proto[methodName].overloadTable[argCount - 2] = memberFunction;\n        }\n        return [];\n      });\n      return [];\n    });\n  }\n\n  var emval_free_list = [];\n\n  var emval_handle_array = [\n    {},\n    {\n      value: undefined,\n    },\n    {\n      value: null,\n    },\n    {\n      value: true,\n    },\n    {\n      value: false,\n    },\n  ];\n\n  function __emval_decref(handle) {\n    if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n      emval_handle_array[handle] = undefined;\n      emval_free_list.push(handle);\n    }\n  }\n\n  function count_emval_handles() {\n    var count = 0;\n    for (var i = 5; i < emval_handle_array.length; ++i) {\n      if (emval_handle_array[i] !== undefined) {\n        ++count;\n      }\n    }\n    return count;\n  }\n\n  function get_first_emval() {\n    for (var i = 5; i < emval_handle_array.length; ++i) {\n      if (emval_handle_array[i] !== undefined) {\n        return emval_handle_array[i];\n      }\n    }\n    return null;\n  }\n\n  function init_emval() {\n    Module.count_emval_handles = count_emval_handles;\n    Module.get_first_emval = get_first_emval;\n  }\n\n  var Emval = {\n    toValue: handle => {\n      if (!handle) {\n        throwBindingError("Cannot use deleted val. handle = " + handle);\n      }\n      return emval_handle_array[handle].value;\n    },\n    toHandle: value => {\n      switch (value) {\n        case undefined:\n          return 1;\n\n        case null:\n          return 2;\n\n        case true:\n          return 3;\n\n        case false:\n          return 4;\n\n        default: {\n          var handle = emval_free_list.length\n            ? emval_free_list.pop()\n            : emval_handle_array.length;\n          emval_handle_array[handle] = {\n            refcount: 1,\n            value,\n          };\n          return handle;\n        }\n      }\n    },\n  };\n\n  function __embind_register_emval(rawType, name) {\n    name = readLatin1String(name);\n    registerType(rawType, {\n      name,\n      fromWireType: function (handle) {\n        var rv = Emval.toValue(handle);\n        __emval_decref(handle);\n        return rv;\n      },\n      toWireType: function (destructors, value) {\n        return Emval.toHandle(value);\n      },\n      argPackAdvance: 8,\n      readValueFromPointer: simpleReadValueFromPointer,\n      destructorFunction: null,\n    });\n  }\n\n  function _embind_repr(v) {\n    if (v === null) {\n      return "null";\n    }\n    var t = typeof v;\n    if (t === "object" || t === "array" || t === "function") {\n      return v.toString();\n    }\n    return "" + v;\n  }\n\n  function floatReadValueFromPointer(name, shift) {\n    switch (shift) {\n      case 2:\n        return function (pointer) {\n          return this.fromWireType(HEAPF32[pointer >> 2]);\n        };\n\n      case 3:\n        return function (pointer) {\n          return this.fromWireType(HEAPF64[pointer >> 3]);\n        };\n\n      default:\n        throw new TypeError("Unknown float type: " + name);\n    }\n  }\n\n  function __embind_register_float(rawType, name, size) {\n    var shift = getShiftFromSize(size);\n    name = readLatin1String(name);\n    registerType(rawType, {\n      name,\n      fromWireType: function (value) {\n        return value;\n      },\n      toWireType: function (destructors, value) {\n        return value;\n      },\n      argPackAdvance: 8,\n      readValueFromPointer: floatReadValueFromPointer(name, shift),\n      destructorFunction: null,\n    });\n  }\n\n  function integerReadValueFromPointer(name, shift, signed) {\n    switch (shift) {\n      case 0:\n        return signed\n          ? function readS8FromPointer(pointer) {\n              return HEAP8[pointer];\n            }\n          : function readU8FromPointer(pointer) {\n              return HEAPU8[pointer];\n            };\n\n      case 1:\n        return signed\n          ? function readS16FromPointer(pointer) {\n              return HEAP16[pointer >> 1];\n            }\n          : function readU16FromPointer(pointer) {\n              return HEAPU16[pointer >> 1];\n            };\n\n      case 2:\n        return signed\n          ? function readS32FromPointer(pointer) {\n              return HEAP32[pointer >> 2];\n            }\n          : function readU32FromPointer(pointer) {\n              return HEAPU32[pointer >> 2];\n            };\n\n      default:\n        throw new TypeError("Unknown integer type: " + name);\n    }\n  }\n\n  function __embind_register_integer(\n    primitiveType,\n    name,\n    size,\n    minRange,\n    maxRange\n  ) {\n    name = readLatin1String(name);\n    if (maxRange === -1) {\n      maxRange = 4294967295;\n    }\n    var shift = getShiftFromSize(size);\n    var fromWireType = value => value;\n    if (minRange === 0) {\n      var bitshift = 32 - 8 * size;\n      fromWireType = value => (value << bitshift) >>> bitshift;\n    }\n    var isUnsignedType = name.includes("unsigned");\n    var checkAssertions = (value, toTypeName) => {};\n    var toWireType;\n    if (isUnsignedType) {\n      toWireType = function (destructors, value) {\n        checkAssertions(value, this.name);\n        return value >>> 0;\n      };\n    } else {\n      toWireType = function (destructors, value) {\n        checkAssertions(value, this.name);\n        return value;\n      };\n    }\n    registerType(primitiveType, {\n      name,\n      fromWireType: fromWireType,\n      toWireType: toWireType,\n      argPackAdvance: 8,\n      readValueFromPointer: integerReadValueFromPointer(\n        name,\n        shift,\n        minRange !== 0\n      ),\n      destructorFunction: null,\n    });\n  }\n\n  function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n    var typeMapping = [\n      Int8Array,\n      Uint8Array,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n    ];\n    var TA = typeMapping[dataTypeIndex];\n    function decodeMemoryView(handle) {\n      handle = handle >> 2;\n      var heap = HEAPU32;\n      var size = heap[handle];\n      var data = heap[handle + 1];\n      return new TA(buffer, data, size);\n    }\n    name = readLatin1String(name);\n    registerType(\n      rawType,\n      {\n        name,\n        fromWireType: decodeMemoryView,\n        argPackAdvance: 8,\n        readValueFromPointer: decodeMemoryView,\n      },\n      {\n        ignoreDuplicateRegistrations: true,\n      }\n    );\n  }\n\n  function __embind_register_smart_ptr(\n    rawType,\n    rawPointeeType,\n    name,\n    sharingPolicy,\n    getPointeeSignature,\n    rawGetPointee,\n    constructorSignature,\n    rawConstructor,\n    shareSignature,\n    rawShare,\n    destructorSignature,\n    rawDestructor\n  ) {\n    name = readLatin1String(name);\n    rawGetPointee = embind__requireFunction(getPointeeSignature, rawGetPointee);\n    rawConstructor = embind__requireFunction(\n      constructorSignature,\n      rawConstructor\n    );\n    rawShare = embind__requireFunction(shareSignature, rawShare);\n    rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n    whenDependentTypesAreResolved(\n      [rawType],\n      [rawPointeeType],\n      function (pointeeType) {\n        pointeeType = pointeeType[0];\n        var registeredPointer = new RegisteredPointer(\n          name,\n          pointeeType.registeredClass,\n          false,\n          false,\n          true,\n          pointeeType,\n          sharingPolicy,\n          rawGetPointee,\n          rawConstructor,\n          rawShare,\n          rawDestructor\n        );\n        return [registeredPointer];\n      }\n    );\n  }\n\n  function __embind_register_std_string(rawType, name) {\n    name = readLatin1String(name);\n    var stdStringIsUTF8 = name === "std::string";\n    registerType(rawType, {\n      name,\n      fromWireType: function (value) {\n        var length = HEAPU32[value >> 2];\n        var str;\n        if (stdStringIsUTF8) {\n          var decodeStartPtr = value + 4;\n          for (var i = 0; i <= length; ++i) {\n            var currentBytePtr = value + 4 + i;\n            if (i == length || HEAPU8[currentBytePtr] == 0) {\n              var maxRead = currentBytePtr - decodeStartPtr;\n              var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n              if (str === undefined) {\n                str = stringSegment;\n              } else {\n                str += String.fromCharCode(0);\n                str += stringSegment;\n              }\n              decodeStartPtr = currentBytePtr + 1;\n            }\n          }\n        } else {\n          var a = new Array(length);\n          for (var i = 0; i < length; ++i) {\n            a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\n          }\n          str = a.join("");\n        }\n        _free(value);\n        return str;\n      },\n      toWireType: function (destructors, value) {\n        if (value instanceof ArrayBuffer) {\n          value = new Uint8Array(value);\n        }\n        var getLength;\n        var valueIsOfTypeString = typeof value == "string";\n        if (\n          !(\n            valueIsOfTypeString ||\n            value instanceof Uint8Array ||\n            value instanceof Uint8ClampedArray ||\n            value instanceof Int8Array\n          )\n        ) {\n          throwBindingError("Cannot pass non-string to std::string");\n        }\n        if (stdStringIsUTF8 && valueIsOfTypeString) {\n          getLength = () => lengthBytesUTF8(value);\n        } else {\n          getLength = () => value.length;\n        }\n        var length = getLength();\n        var ptr = _malloc(4 + length + 1);\n        HEAPU32[ptr >> 2] = length;\n        if (stdStringIsUTF8 && valueIsOfTypeString) {\n          stringToUTF8(value, ptr + 4, length + 1);\n        } else if (valueIsOfTypeString) {\n          for (var i = 0; i < length; ++i) {\n            var charCode = value.charCodeAt(i);\n            if (charCode > 255) {\n              _free(ptr);\n              throwBindingError(\n                "String has UTF-16 code units that do not fit in 8 bits"\n              );\n            }\n            HEAPU8[ptr + 4 + i] = charCode;\n          }\n        } else {\n          for (var i = 0; i < length; ++i) {\n            HEAPU8[ptr + 4 + i] = value[i];\n          }\n        }\n        if (destructors !== null) {\n          destructors.push(_free, ptr);\n        }\n        return ptr;\n      },\n      argPackAdvance: 8,\n      readValueFromPointer: simpleReadValueFromPointer,\n      destructorFunction(ptr) {\n        _free(ptr);\n      },\n    });\n  }\n\n  function __embind_register_std_wstring(rawType, charSize, name) {\n    name = readLatin1String(name);\n    var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n    if (charSize === 2) {\n      decodeString = UTF16ToString;\n      encodeString = stringToUTF16;\n      lengthBytesUTF = lengthBytesUTF16;\n      getHeap = () => HEAPU16;\n      shift = 1;\n    } else if (charSize === 4) {\n      decodeString = UTF32ToString;\n      encodeString = stringToUTF32;\n      lengthBytesUTF = lengthBytesUTF32;\n      getHeap = () => HEAPU32;\n      shift = 2;\n    }\n    registerType(rawType, {\n      name,\n      fromWireType: function (value) {\n        var length = HEAPU32[value >> 2];\n        var HEAP = getHeap();\n        var str;\n        var decodeStartPtr = value + 4;\n        for (var i = 0; i <= length; ++i) {\n          var currentBytePtr = value + 4 + i * charSize;\n          if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n            var maxReadBytes = currentBytePtr - decodeStartPtr;\n            var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n            if (str === undefined) {\n              str = stringSegment;\n            } else {\n              str += String.fromCharCode(0);\n              str += stringSegment;\n            }\n            decodeStartPtr = currentBytePtr + charSize;\n          }\n        }\n        _free(value);\n        return str;\n      },\n      toWireType: function (destructors, value) {\n        if (!(typeof value == "string")) {\n          throwBindingError(\n            "Cannot pass non-string to C++ string type " + name\n          );\n        }\n        var length = lengthBytesUTF(value);\n        var ptr = _malloc(4 + length + charSize);\n        HEAPU32[ptr >> 2] = length >> shift;\n        encodeString(value, ptr + 4, length + charSize);\n        if (destructors !== null) {\n          destructors.push(_free, ptr);\n        }\n        return ptr;\n      },\n      argPackAdvance: 8,\n      readValueFromPointer: simpleReadValueFromPointer,\n      destructorFunction(ptr) {\n        _free(ptr);\n      },\n    });\n  }\n\n  function __embind_register_value_object(\n    rawType,\n    name,\n    constructorSignature,\n    rawConstructor,\n    destructorSignature,\n    rawDestructor\n  ) {\n    structRegistrations[rawType] = {\n      name: readLatin1String(name),\n      rawConstructor: embind__requireFunction(\n        constructorSignature,\n        rawConstructor\n      ),\n      rawDestructor: embind__requireFunction(\n        destructorSignature,\n        rawDestructor\n      ),\n      fields: [],\n    };\n  }\n\n  function __embind_register_value_object_field(\n    structType,\n    fieldName,\n    getterReturnType,\n    getterSignature,\n    getter,\n    getterContext,\n    setterArgumentType,\n    setterSignature,\n    setter,\n    setterContext\n  ) {\n    structRegistrations[structType].fields.push({\n      fieldName: readLatin1String(fieldName),\n      getterReturnType,\n      getter: embind__requireFunction(getterSignature, getter),\n      getterContext,\n      setterArgumentType,\n      setter: embind__requireFunction(setterSignature, setter),\n      setterContext,\n    });\n  }\n\n  function __embind_register_void(rawType, name) {\n    name = readLatin1String(name);\n    registerType(rawType, {\n      isVoid: true,\n      name,\n      argPackAdvance: 0,\n      fromWireType: function () {\n        return undefined;\n      },\n      toWireType: function (destructors, o) {\n        return undefined;\n      },\n    });\n  }\n\n  function __emscripten_date_now() {\n    return Date.now();\n  }\n\n  var nowIsMonotonic = true;\n\n  function __emscripten_get_now_is_monotonic() {\n    return nowIsMonotonic;\n  }\n\n  function requireRegisteredType(rawType, humanName) {\n    var impl = registeredTypes[rawType];\n    if (undefined === impl) {\n      throwBindingError(\n        humanName + " has unknown type " + getTypeName(rawType)\n      );\n    }\n    return impl;\n  }\n\n  function __emval_lookupTypes(argCount, argTypes) {\n    var a = new Array(argCount);\n    for (var i = 0; i < argCount; ++i) {\n      a[i] = requireRegisteredType(\n        HEAP32[(argTypes >> 2) + i],\n        "parameter " + i\n      );\n    }\n    return a;\n  }\n\n  function __emval_call(handle, argCount, argTypes, argv) {\n    handle = Emval.toValue(handle);\n    var types = __emval_lookupTypes(argCount, argTypes);\n    var args = new Array(argCount);\n    for (var i = 0; i < argCount; ++i) {\n      var type = types[i];\n      args[i] = type.readValueFromPointer(argv);\n      argv += type.argPackAdvance;\n    }\n    var rv = handle.apply(undefined, args);\n    return Emval.toHandle(rv);\n  }\n\n  function __emval_incref(handle) {\n    if (handle > 4) {\n      emval_handle_array[handle].refcount += 1;\n    }\n  }\n\n  function __emval_take_value(type, argv) {\n    type = requireRegisteredType(type, "_emval_take_value");\n    var v = type.readValueFromPointer(argv);\n    return Emval.toHandle(v);\n  }\n\n  function __localtime_js(time, tmPtr) {\n    var date = new Date(HEAP32[time >> 2] * 1e3);\n    HEAP32[tmPtr >> 2] = date.getSeconds();\n    HEAP32[(tmPtr + 4) >> 2] = date.getMinutes();\n    HEAP32[(tmPtr + 8) >> 2] = date.getHours();\n    HEAP32[(tmPtr + 12) >> 2] = date.getDate();\n    HEAP32[(tmPtr + 16) >> 2] = date.getMonth();\n    HEAP32[(tmPtr + 20) >> 2] = date.getFullYear() - 1900;\n    HEAP32[(tmPtr + 24) >> 2] = date.getDay();\n    var start = new Date(date.getFullYear(), 0, 1);\n    var yday = ((date.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24)) | 0;\n    HEAP32[(tmPtr + 28) >> 2] = yday;\n    HEAP32[(tmPtr + 36) >> 2] = -(date.getTimezoneOffset() * 60);\n    var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();\n    var winterOffset = start.getTimezoneOffset();\n    var dst =\n      (summerOffset != winterOffset &&\n        date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;\n    HEAP32[(tmPtr + 32) >> 2] = dst;\n  }\n\n  function __mmap_js(addr, len, prot, flags, fd, off, allocated, builtin) {\n    return -52;\n  }\n\n  function __munmap_js(addr, len, prot, flags, fd, offset) {}\n\n  function _tzset_impl(timezone, daylight, tzname) {\n    var currentYear = new Date().getFullYear();\n    var winter = new Date(currentYear, 0, 1);\n    var summer = new Date(currentYear, 6, 1);\n    var winterOffset = winter.getTimezoneOffset();\n    var summerOffset = summer.getTimezoneOffset();\n    var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\n    HEAP32[timezone >> 2] = stdTimezoneOffset * 60;\n    HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);\n    function extractZone(date) {\n      var match = date.toTimeString().match(/\\(([A-Za-z ]+)\\)$/);\n      return match ? match[1] : "GMT";\n    }\n    var winterName = extractZone(winter);\n    var summerName = extractZone(summer);\n    var winterNamePtr = allocateUTF8(winterName);\n    var summerNamePtr = allocateUTF8(summerName);\n    if (summerOffset < winterOffset) {\n      HEAP32[tzname >> 2] = winterNamePtr;\n      HEAP32[(tzname + 4) >> 2] = summerNamePtr;\n    } else {\n      HEAP32[tzname >> 2] = summerNamePtr;\n      HEAP32[(tzname + 4) >> 2] = winterNamePtr;\n    }\n  }\n\n  function __tzset_js(timezone, daylight, tzname) {\n    if (__tzset_js.called) {\n      return;\n    }\n    __tzset_js.called = true;\n    _tzset_impl(timezone, daylight, tzname);\n  }\n\n  function _abort() {\n    abort("");\n  }\n\n  var readAsmConstArgsArray = [];\n\n  function readAsmConstArgs(sigPtr, buf) {\n    readAsmConstArgsArray.length = 0;\n    var ch;\n    buf >>= 2;\n    while ((ch = HEAPU8[sigPtr++])) {\n      var readAsmConstArgsDouble = ch < 105;\n      if (readAsmConstArgsDouble && buf & 1) {\n        buf++;\n      }\n      readAsmConstArgsArray.push(\n        readAsmConstArgsDouble ? HEAPF64[buf++ >> 1] : HEAP32[buf]\n      );\n      ++buf;\n    }\n    return readAsmConstArgsArray;\n  }\n\n  function _emscripten_asm_const_int(code, sigPtr, argbuf) {\n    var args = readAsmConstArgs(sigPtr, argbuf);\n    return ASM_CONSTS[code].apply(null, args);\n  }\n\n  function _emscripten_get_heap_max() {\n    return 2147483648;\n  }\n\n  var _emscripten_get_now;\n\n  _emscripten_get_now = () => performance.now();\n\n  function _emscripten_memcpy_big(dest, src, num) {\n    HEAPU8.copyWithin(dest, src, src + num);\n  }\n\n  function emscripten_realloc_buffer(size) {\n    try {\n      wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16);\n      updateGlobalBufferAndViews(wasmMemory.buffer);\n      return 1;\n    } catch (e) {}\n  }\n\n  function _emscripten_resize_heap(requestedSize) {\n    var oldSize = HEAPU8.length;\n    requestedSize = requestedSize >>> 0;\n    var maxHeapSize = _emscripten_get_heap_max();\n    if (requestedSize > maxHeapSize) {\n      return false;\n    }\n    let alignUp = (x, multiple) => x + ((multiple - (x % multiple)) % multiple);\n    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n      overGrownHeapSize = Math.min(\n        overGrownHeapSize,\n        requestedSize + 100663296\n      );\n      var newSize = Math.min(\n        maxHeapSize,\n        alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)\n      );\n      var replacement = emscripten_realloc_buffer(newSize);\n      if (replacement) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  var ENV = {};\n\n  function getExecutableName() {\n    return thisProgram || "./this.program";\n  }\n\n  function getEnvStrings() {\n    if (!getEnvStrings.strings) {\n      var lang =\n        (\n          (typeof navigator == "object" &&\n            navigator.languages &&\n            navigator.languages[0]) ||\n          "C"\n        ).replace("-", "_") + ".UTF-8";\n      var env = {\n        USER: "web_user",\n        LOGNAME: "web_user",\n        PATH: "/",\n        PWD: "/",\n        HOME: "/home/web_user",\n        LANG: lang,\n        _: getExecutableName(),\n      };\n      for (var x in ENV) {\n        if (ENV[x] === undefined) {\n          delete env[x];\n        } else {\n          env[x] = ENV[x];\n        }\n      }\n      var strings = [];\n      for (var x in env) {\n        strings.push(x + "=" + env[x]);\n      }\n      getEnvStrings.strings = strings;\n    }\n    return getEnvStrings.strings;\n  }\n\n  function _environ_get(__environ, environ_buf) {\n    var bufSize = 0;\n    getEnvStrings().forEach(function (string, i) {\n      var ptr = environ_buf + bufSize;\n      HEAP32[(__environ + i * 4) >> 2] = ptr;\n      writeAsciiToMemory(string, ptr);\n      bufSize += string.length + 1;\n    });\n    return 0;\n  }\n\n  function _environ_sizes_get(penviron_count, penviron_buf_size) {\n    var strings = getEnvStrings();\n    HEAP32[penviron_count >> 2] = strings.length;\n    var bufSize = 0;\n    strings.forEach(function (string) {\n      bufSize += string.length + 1;\n    });\n    HEAP32[penviron_buf_size >> 2] = bufSize;\n    return 0;\n  }\n\n  function _exit(status) {\n    exit(status);\n  }\n\n  function _fd_close(fd) {\n    return 0;\n  }\n\n  function _fd_read(fd, iov, iovcnt, pnum) {\n    var stream = SYSCALLS.getStreamFromFD(fd);\n    var num = SYSCALLS.doReadv(stream, iov, iovcnt);\n    HEAP32[pnum >> 2] = num;\n    return 0;\n  }\n\n  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {}\n\n  function _fd_write(fd, iov, iovcnt, pnum) {\n    var num = 0;\n    for (var i = 0; i < iovcnt; i++) {\n      var ptr = HEAP32[iov >> 2];\n      var len = HEAP32[(iov + 4) >> 2];\n      iov += 8;\n      for (var j = 0; j < len; j++) {\n        SYSCALLS.printChar(fd, HEAPU8[ptr + j]);\n      }\n      num += len;\n    }\n    HEAP32[pnum >> 2] = num;\n    return 0;\n  }\n\n  function getRandomDevice() {\n    if (\n      typeof crypto == "object" &&\n      typeof crypto.getRandomValues == "function"\n    ) {\n      var randomBuffer = new Uint8Array(1);\n      return function () {\n        crypto.getRandomValues(randomBuffer);\n        return randomBuffer[0];\n      };\n    }\n    return function () {\n      abort("randomDevice");\n    };\n  }\n\n  function _getentropy(buffer, size) {\n    if (!_getentropy.randomDevice) {\n      _getentropy.randomDevice = getRandomDevice();\n    }\n    for (var i = 0; i < size; i++) {\n      HEAP8[(buffer + i) >> 0] = _getentropy.randomDevice();\n    }\n    return 0;\n  }\n\n  function _pclose() {\n    err("missing function: pclose");\n    abort(-1);\n  }\n\n  function _setTempRet0(val) {\n    setTempRet0(val);\n  }\n\n  function __isLeapYear(year) {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n  }\n\n  function __arraySum(array, index) {\n    var sum = 0;\n    for (var i = 0; i <= index; sum += array[i++]) {}\n    return sum;\n  }\n\n  var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n  var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n  function __addDays(date, days) {\n    var newDate = new Date(date.getTime());\n    while (days > 0) {\n      var leap = __isLeapYear(newDate.getFullYear());\n      var currentMonth = newDate.getMonth();\n      var daysInCurrentMonth = (\n        leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR\n      )[currentMonth];\n      if (days > daysInCurrentMonth - newDate.getDate()) {\n        days -= daysInCurrentMonth - newDate.getDate() + 1;\n        newDate.setDate(1);\n        if (currentMonth < 11) {\n          newDate.setMonth(currentMonth + 1);\n        } else {\n          newDate.setMonth(0);\n          newDate.setFullYear(newDate.getFullYear() + 1);\n        }\n      } else {\n        newDate.setDate(newDate.getDate() + days);\n        return newDate;\n      }\n    }\n    return newDate;\n  }\n\n  function _strftime(s, maxsize, format, tm) {\n    var tm_zone = HEAP32[(tm + 40) >> 2];\n    var date = {\n      tm_sec: HEAP32[tm >> 2],\n      tm_min: HEAP32[(tm + 4) >> 2],\n      tm_hour: HEAP32[(tm + 8) >> 2],\n      tm_mday: HEAP32[(tm + 12) >> 2],\n      tm_mon: HEAP32[(tm + 16) >> 2],\n      tm_year: HEAP32[(tm + 20) >> 2],\n      tm_wday: HEAP32[(tm + 24) >> 2],\n      tm_yday: HEAP32[(tm + 28) >> 2],\n      tm_isdst: HEAP32[(tm + 32) >> 2],\n      tm_gmtoff: HEAP32[(tm + 36) >> 2],\n      tm_zone: tm_zone ? UTF8ToString(tm_zone) : "",\n    };\n    var pattern = UTF8ToString(format);\n    var EXPANSION_RULES_1 = {\n      "%c": "%a %b %d %H:%M:%S %Y",\n      "%D": "%m/%d/%y",\n      "%F": "%Y-%m-%d",\n      "%h": "%b",\n      "%r": "%I:%M:%S %p",\n      "%R": "%H:%M",\n      "%T": "%H:%M:%S",\n      "%x": "%m/%d/%y",\n      "%X": "%H:%M:%S",\n      "%Ec": "%c",\n      "%EC": "%C",\n      "%Ex": "%m/%d/%y",\n      "%EX": "%H:%M:%S",\n      "%Ey": "%y",\n      "%EY": "%Y",\n      "%Od": "%d",\n      "%Oe": "%e",\n      "%OH": "%H",\n      "%OI": "%I",\n      "%Om": "%m",\n      "%OM": "%M",\n      "%OS": "%S",\n      "%Ou": "%u",\n      "%OU": "%U",\n      "%OV": "%V",\n      "%Ow": "%w",\n      "%OW": "%W",\n      "%Oy": "%y",\n    };\n    for (var rule in EXPANSION_RULES_1) {\n      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);\n    }\n    var WEEKDAYS = [\n      "Sunday",\n      "Monday",\n      "Tuesday",\n      "Wednesday",\n      "Thursday",\n      "Friday",\n      "Saturday",\n    ];\n    var MONTHS = [\n      "January",\n      "February",\n      "March",\n      "April",\n      "May",\n      "June",\n      "July",\n      "August",\n      "September",\n      "October",\n      "November",\n      "December",\n    ];\n    function leadingSomething(value, digits, character) {\n      var str = typeof value == "number" ? value.toString() : value || "";\n      while (str.length < digits) {\n        str = character[0] + str;\n      }\n      return str;\n    }\n    function leadingNulls(value, digits) {\n      return leadingSomething(value, digits, "0");\n    }\n    function compareByDay(date1, date2) {\n      function sgn(value) {\n        return value < 0 ? -1 : value > 0 ? 1 : 0;\n      }\n      var compare;\n      if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n        if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n          compare = sgn(date1.getDate() - date2.getDate());\n        }\n      }\n      return compare;\n    }\n    function getFirstWeekStartDate(janFourth) {\n      switch (janFourth.getDay()) {\n        case 0:\n          return new Date(janFourth.getFullYear() - 1, 11, 29);\n\n        case 1:\n          return janFourth;\n\n        case 2:\n          return new Date(janFourth.getFullYear(), 0, 3);\n\n        case 3:\n          return new Date(janFourth.getFullYear(), 0, 2);\n\n        case 4:\n          return new Date(janFourth.getFullYear(), 0, 1);\n\n        case 5:\n          return new Date(janFourth.getFullYear() - 1, 11, 31);\n\n        case 6:\n          return new Date(janFourth.getFullYear() - 1, 11, 30);\n      }\n    }\n    function getWeekBasedYear(date) {\n      var thisDate = __addDays(\n        new Date(date.tm_year + 1900, 0, 1),\n        date.tm_yday\n      );\n      var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n      var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n      if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n        if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n          return thisDate.getFullYear() + 1;\n        }\n        return thisDate.getFullYear();\n      }\n      return thisDate.getFullYear() - 1;\n    }\n    var EXPANSION_RULES_2 = {\n      "%a": function (date) {\n        return WEEKDAYS[date.tm_wday].substring(0, 3);\n      },\n      "%A": function (date) {\n        return WEEKDAYS[date.tm_wday];\n      },\n      "%b": function (date) {\n        return MONTHS[date.tm_mon].substring(0, 3);\n      },\n      "%B": function (date) {\n        return MONTHS[date.tm_mon];\n      },\n      "%C": function (date) {\n        var year = date.tm_year + 1900;\n        return leadingNulls((year / 100) | 0, 2);\n      },\n      "%d": function (date) {\n        return leadingNulls(date.tm_mday, 2);\n      },\n      "%e": function (date) {\n        return leadingSomething(date.tm_mday, 2, " ");\n      },\n      "%g": function (date) {\n        return getWeekBasedYear(date).toString().substring(2);\n      },\n      "%G": function (date) {\n        return getWeekBasedYear(date);\n      },\n      "%H": function (date) {\n        return leadingNulls(date.tm_hour, 2);\n      },\n      "%I": function (date) {\n        var twelveHour = date.tm_hour;\n        if (twelveHour == 0) {\n          twelveHour = 12;\n        } else if (twelveHour > 12) {\n          twelveHour -= 12;\n        }\n        return leadingNulls(twelveHour, 2);\n      },\n      "%j": function (date) {\n        return leadingNulls(\n          date.tm_mday +\n            __arraySum(\n              __isLeapYear(date.tm_year + 1900)\n                ? __MONTH_DAYS_LEAP\n                : __MONTH_DAYS_REGULAR,\n              date.tm_mon - 1\n            ),\n          3\n        );\n      },\n      "%m": function (date) {\n        return leadingNulls(date.tm_mon + 1, 2);\n      },\n      "%M": function (date) {\n        return leadingNulls(date.tm_min, 2);\n      },\n      "%n": function () {\n        return "\\n";\n      },\n      "%p": function (date) {\n        if (date.tm_hour >= 0 && date.tm_hour < 12) {\n          return "AM";\n        }\n        return "PM";\n      },\n      "%S": function (date) {\n        return leadingNulls(date.tm_sec, 2);\n      },\n      "%t": function () {\n        return "\\t";\n      },\n      "%u": function (date) {\n        return date.tm_wday || 7;\n      },\n      "%U": function (date) {\n        var days = date.tm_yday + 7 - date.tm_wday;\n        return leadingNulls(Math.floor(days / 7), 2);\n      },\n      "%V": function (date) {\n        var val = Math.floor((date.tm_yday + 7 - ((date.tm_wday + 6) % 7)) / 7);\n        if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\n          val++;\n        }\n        if (!val) {\n          val = 52;\n          var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\n          if (\n            dec31 == 4 ||\n            (dec31 == 5 && __isLeapYear((date.tm_year % 400) - 1))\n          ) {\n            val++;\n          }\n        } else if (val == 53) {\n          var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\n          if (jan1 != 4 && (jan1 != 3 || !__isLeapYear(date.tm_year))) {\n            val = 1;\n          }\n        }\n        return leadingNulls(val, 2);\n      },\n      "%w": function (date) {\n        return date.tm_wday;\n      },\n      "%W": function (date) {\n        var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7);\n        return leadingNulls(Math.floor(days / 7), 2);\n      },\n      "%y": function (date) {\n        return (date.tm_year + 1900).toString().substring(2);\n      },\n      "%Y": function (date) {\n        return date.tm_year + 1900;\n      },\n      "%z": function (date) {\n        var off = date.tm_gmtoff;\n        var ahead = off >= 0;\n        off = Math.abs(off) / 60;\n        off = (off / 60) * 100 + (off % 60);\n        return (ahead ? "+" : "-") + String("0000" + off).slice(-4);\n      },\n      "%Z": function (date) {\n        return date.tm_zone;\n      },\n      "%%": function () {\n        return "%";\n      },\n    };\n    pattern = pattern.replace(/%%/g, "\\0\\0");\n    for (var rule in EXPANSION_RULES_2) {\n      if (pattern.includes(rule)) {\n        pattern = pattern.replace(\n          new RegExp(rule, "g"),\n          EXPANSION_RULES_2[rule](date)\n        );\n      }\n    }\n    pattern = pattern.replace(/\\0\\0/g, "%");\n    var bytes = intArrayFromString(pattern, false);\n    if (bytes.length > maxsize) {\n      return 0;\n    }\n    writeArrayToMemory(bytes, s);\n    return bytes.length - 1;\n  }\n\n  function _strftime_l(s, maxsize, format, tm) {\n    return _strftime(s, maxsize, format, tm);\n  }\n\n  InternalError = Module.InternalError = extendError(Error, "InternalError");\n\n  embind_init_charCodes();\n\n  BindingError = Module.BindingError = extendError(Error, "BindingError");\n\n  init_ClassHandle();\n\n  init_embind();\n\n  init_RegisteredPointer();\n\n  UnboundTypeError = Module.UnboundTypeError = extendError(\n    Error,\n    "UnboundTypeError"\n  );\n\n  init_emval();\n\n  function intArrayFromString(stringy, dontAddNull, length) {\n    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n    var u8array = new Array(len);\n    var numBytesWritten = stringToUTF8Array(\n      stringy,\n      u8array,\n      0,\n      u8array.length\n    );\n    if (dontAddNull) {\n      u8array.length = numBytesWritten;\n    }\n    return u8array;\n  }\n\n  var asmLibraryArg = {\n    __assert_fail: ___assert_fail,\n    __cxa_allocate_exception: ___cxa_allocate_exception,\n    __cxa_rethrow: ___cxa_rethrow,\n    __cxa_throw: ___cxa_throw,\n    __syscall_faccessat: ___syscall_faccessat,\n    __syscall_fcntl64: ___syscall_fcntl64,\n    __syscall_fstat64: ___syscall_fstat64,\n    __syscall_getcwd: ___syscall_getcwd,\n    __syscall_ioctl: ___syscall_ioctl,\n    __syscall_lstat64: ___syscall_lstat64,\n    __syscall_newfstatat: ___syscall_newfstatat,\n    __syscall_openat: ___syscall_openat,\n    __syscall_renameat: ___syscall_renameat,\n    __syscall_rmdir: ___syscall_rmdir,\n    __syscall_stat64: ___syscall_stat64,\n    __syscall_unlinkat: ___syscall_unlinkat,\n    _embind_finalize_value_object: __embind_finalize_value_object,\n    _embind_register_bigint: __embind_register_bigint,\n    _embind_register_bool: __embind_register_bool,\n    _embind_register_class: __embind_register_class,\n    _embind_register_class_constructor: __embind_register_class_constructor,\n    _embind_register_class_function: __embind_register_class_function,\n    _embind_register_emval: __embind_register_emval,\n    _embind_register_float: __embind_register_float,\n    _embind_register_integer: __embind_register_integer,\n    _embind_register_memory_view: __embind_register_memory_view,\n    _embind_register_smart_ptr: __embind_register_smart_ptr,\n    _embind_register_std_string: __embind_register_std_string,\n    _embind_register_std_wstring: __embind_register_std_wstring,\n    _embind_register_value_object: __embind_register_value_object,\n    _embind_register_value_object_field: __embind_register_value_object_field,\n    _embind_register_void: __embind_register_void,\n    _emscripten_date_now: __emscripten_date_now,\n    _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,\n    _emval_call: __emval_call,\n    _emval_decref: __emval_decref,\n    _emval_incref: __emval_incref,\n    _emval_take_value: __emval_take_value,\n    _localtime_js: __localtime_js,\n    _mmap_js: __mmap_js,\n    _munmap_js: __munmap_js,\n    _tzset_js: __tzset_js,\n    abort: _abort,\n    emscripten_asm_const_int: _emscripten_asm_const_int,\n    emscripten_get_heap_max: _emscripten_get_heap_max,\n    emscripten_get_now: _emscripten_get_now,\n    emscripten_memcpy_big: _emscripten_memcpy_big,\n    emscripten_resize_heap: _emscripten_resize_heap,\n    environ_get: _environ_get,\n    environ_sizes_get: _environ_sizes_get,\n    exit: _exit,\n    fd_close: _fd_close,\n    fd_read: _fd_read,\n    fd_seek: _fd_seek,\n    fd_write: _fd_write,\n    getentropy: _getentropy,\n    memory: wasmMemory,\n    pclose: _pclose,\n    setTempRet0: _setTempRet0,\n    strftime_l: _strftime_l,\n  };\n\n  var asm = createWasm();\n\n  var calledRun;\n\n  function ExitStatus(status) {\n    this.name = "ExitStatus";\n    this.message = "Program terminated with exit(" + status + ")";\n    this.status = status;\n  }\n\n  dependenciesFulfilled = function runCaller() {\n    if (!calledRun) {\n      run();\n    }\n    if (!calledRun) {\n      dependenciesFulfilled = runCaller;\n    }\n  };\n\n  function run(args) {\n    args = args || arguments_;\n    if (runDependencies > 0) {\n      return;\n    }\n    preRun();\n    if (runDependencies > 0) {\n      return;\n    }\n    function doRun() {\n      if (calledRun) {\n        return;\n      }\n      calledRun = true;\n      Module.calledRun = true;\n      if (ABORT) {\n        return;\n      }\n      initRuntime();\n      if (Module.onRuntimeInitialized) {\n        Module.onRuntimeInitialized();\n      }\n      postRun();\n    }\n    if (Module.setStatus) {\n      Module.setStatus("Running...");\n      setTimeout(function () {\n        setTimeout(function () {\n          Module.setStatus("");\n        }, 1);\n        doRun();\n      }, 1);\n    } else {\n      doRun();\n    }\n  }\n\n  Module.run = run;\n\n  function exit(status, implicit) {\n    EXITSTATUS = status;\n    procExit(status);\n  }\n\n  function procExit(code) {\n    EXITSTATUS = code;\n    if (!keepRuntimeAlive()) {\n      if (Module.onExit) {\n        Module.onExit(code);\n      }\n      ABORT = true;\n    }\n    quit_(code, new ExitStatus(code));\n  }\n\n  if (Module.preInit) {\n    if (typeof Module.preInit == "function") {\n      Module.preInit = [Module.preInit];\n    }\n    while (Module.preInit.length) {\n      Module.preInit.pop()();\n    }\n  }\n\n  run();\n\n  /* Use an optimized gemm implementation if available, otherwise use the fallback\n   * implementation.\n   */\n  function createWasmGemm() {\n    // A map of expected gemm function to the corresponding fallback gemm function names.\n    const GEMM_TO_FALLBACK_FUNCTIONS_MAP = {\n      int8_prepare_a: "int8PrepareAFallback",\n      int8_prepare_b: "int8PrepareBFallback",\n      int8_prepare_b_from_transposed: "int8PrepareBFromTransposedFallback",\n      int8_prepare_b_from_quantized_transposed:\n        "int8PrepareBFromQuantizedTransposedFallback",\n      int8_prepare_bias: "int8PrepareBiasFallback",\n      int8_multiply_and_add_bias: "int8MultiplyAndAddBiasFallback",\n      int8_select_columns_of_b: "int8SelectColumnsOfBFallback",\n    };\n\n    // Name of the optimized gemm implementation.\n    const OPTIMIZED_GEMM = "mozIntGemm";\n\n    const optimizedGemmModule = WebAssembly[OPTIMIZED_GEMM];\n    if (!optimizedGemmModule) {\n      return fallbackGemm(GEMM_TO_FALLBACK_FUNCTIONS_MAP);\n    }\n\n    const optimizedGemmModuleExports = new WebAssembly.Instance(\n      optimizedGemmModule(),\n      { "": { memory: wasmMemory } }\n    ).exports;\n    for (let key in GEMM_TO_FALLBACK_FUNCTIONS_MAP) {\n      if (!optimizedGemmModuleExports[key]) {\n        return fallbackGemm(GEMM_TO_FALLBACK_FUNCTIONS_MAP);\n      }\n    }\n    Module.print(`Using optimized gemm (${OPTIMIZED_GEMM}) implementation`);\n    return optimizedGemmModuleExports;\n  }\n\n  // Return the fallback gemm implementation.\n  function fallbackGemm(gemmToFallbackFunctionsMap) {\n    // The fallback gemm implementation\n    const FALLBACK_GEMM = "asm";\n\n    let fallbackGemmModuleExports = {};\n    for (let key in gemmToFallbackFunctionsMap) {\n      fallbackGemmModuleExports[key] = (...a) =>\n        Module[FALLBACK_GEMM][gemmToFallbackFunctionsMap[key]](...a);\n    }\n    Module.print(`Using fallback gemm implementation`);\n    return fallbackGemmModuleExports;\n  }\n\n  return Module;\n}\n'},4642:n=>{n.exports=function(n){function e(n){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",n)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(n):"undefined"!=typeof eval?eval.call(null,n):e("EvalError: No eval function available")}catch(n){e(n)}}},5882:(n,e,t)=>{t(4642)(t(9825))}},e={};function t(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return n[r](i,i.exports,t),i.exports}t.n=n=>{var e=n&&n.__esModule?()=>n.default:()=>n;return t.d(e,{a:e}),e},t.d=(n,e)=>{for(var r in e)t.o(e,r)&&!t.o(n,r)&&Object.defineProperty(n,r,{enumerable:!0,get:e[r]})},t.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),(()=>{"use strict";t(5882);const n=()=>{},e=()=>performance.now();let r="Error";function a(...n){"Error"!==r&&"Warn"!==r&&console.log("Translations:",...n)}function i(...n){"Trace"!==r&&"All"!==r||console.log("Translations:",...n)}self.addEventListener("unhandledrejection",(n=>{throw n.reason}));const s={model:256,lex:64,vocab:64,qualityModel:64,srcvocab:64,trgvocab:64},o=/^(\s*)(.*?)(\s*)$/s,u=/([])/g,l=["ja","ko","zh"];addEventListener("message",(async function t({data:s}){const f=e();if("initialize"===s.type){try{const{sourceLanguage:e,targetLanguage:t,enginePayload:p,logLevel:g,innerWindowId:h}=s;if(!e)throw new Error('Worker initialization missing "sourceLanguage"');if(!t)throw new Error('Worker initialization missing "targetLanguage"');let _;if(g&&(r=g),p.isMocked)_=new m(e,t);else{const{bergamotWasmArrayBuffer:n,translationModelPayloads:r}=p,a=await c.initializeWasm(n);_=new d(e,t,a,r),n.transfer();for(const{languageModelFiles:n}of r)for(const e of Object.values(n))e.buffer.transfer()}n("TranslationsWorker",{startTime:f,innerWindowId:h},"Translations engine loaded."),function(e){let t;addEventListener("message",(async({data:r})=>{try{if("initialize"===r.type)throw new Error("The Translations engine must not be re-initialized.");switch("translation-request"===r.type?i("Received message",r):a("Received message",r),r.type){case"translation-request":{const{sourceText:n,messageId:a,translationId:s,isHTML:d,innerWindowId:c}=r;t&&await t;try{const{whitespaceBefore:t,whitespaceAfter:r,cleanedSourceText:m}=function(n,e){const t=o.exec(e);if(!t)throw new Error("The whitespace regex should always return a result.");const r=t[1],a=t[3];let i=t[2];return i=i.replaceAll("",""),l.includes(n)&&(i=i.replaceAll(u,"$1 ")),{whitespaceBefore:r,whitespaceAfter:a,cleanedSourceText:i}}(e.sourceLanguage,n);let{targetText:f,inferenceMilliseconds:p}=await e.translate(m,d,c,s);f=t+f+r,i("Translation complete",{sourceText:n,targetText:f,isHTML:d,innerWindowId:c}),postMessage({type:"translation-response",targetText:f,inferenceMilliseconds:p,translationId:s,messageId:a})}catch(n){console.error(n);let e="An error occurred in the engine worker.";"string"==typeof n?.message&&(e=n.message);let t="(no stack)";"string"==typeof n?.stack&&(t=n.stack),postMessage({type:"translation-error",error:{message:e,stack:t},messageId:a,innerWindowId:c})}break}case"discard-translation-queue":n("TranslationsWorker",{innerWindowId:r.innerWindowId},"Translations discard requested"),t=e.discardTranslations(r.innerWindowId),await t,t=null,postMessage({type:"translations-discarded"});break;case"cancel-single-translation":e.discardSingleTranslation(r.innerWindowId,r.translationId);break;default:console.warn("Unknown message type:",r.type)}}catch(n){console.error(n)}}))}(_),postMessage({type:"initialization-success"})}catch(n){console.error(n),postMessage({type:"initialization-error",error:n?.message})}removeEventListener("message",t)}else console.error("The TranslationEngine worker received a message before it was initialized.")}));class d{constructor(n,e,t,r){this.sourceLanguage=n,this.targetLanguage=e,this.bergamot=t,this.languageTranslationModels=r.map((n=>c.constructSingleTranslationModel(t,n))),this.translationService=new t.BlockingService({cacheSize:0})}translate(n,e,t,r){return this.#n(t).runTask(r,(()=>this.#e(n,e,t)))}#t=new Map;#n(n){let e=this.#t.get(n);return e||(e=new f(n),this.#t.set(n,e),e)}discardTranslations(n){let e=this.#t.get(n);e&&(e.cancelWork(),this.#t.delete(n))}discardSingleTranslation(n,e){const t=this.#t.get(n);t&&(i("Discarding translation with translationId",e),t.cancelTask(e))}#e(t,r,a){const i=e(),{messages:s,options:o}=c.getTranslationArgs(this.bergamot,t,r);try{if(0===s.size())return[];let r;if(1===this.languageTranslationModels.length)r=this.translationService.translate(this.languageTranslationModels[0],s,o);else{if(2!==this.languageTranslationModels.length)throw new Error("Too many models were provided to the translation worker.");r=this.translationService.translateViaPivoting(this.languageTranslationModels[0],this.languageTranslationModels[1],s,o)}n("TranslationsWorker",{startTime:i,innerWindowId:a},`Translated ${t.length} code units.`);const u=e();return{targetText:r.get(0).getTranslatedText(),inferenceMilliseconds:u-i}}finally{s?.delete(),o?.delete()}}}class c{static constructSingleTranslationModel(n,e){a("Constructing translation model.");const{sourceLanguage:t,targetLanguage:r,languageModelFiles:i}=e,{model:s,lex:o,vocab:u,qualityModel:l,srcvocab:d,trgvocab:m}=c.allocateModelMemory(n,i),f=n=>Math.floor(n.size()/1e5)/10+"mb";let p="Model memory sizes in wasm heap:";p+=`\n  Model: ${f(s)}`,o&&(p+=`\n  Shortlist: ${f(o)}`);const g=new n.AlignedMemoryList;if(u)g.push_back(u),p+=`\n  Vocab: ${f(u)}`;else{if(!d||!m)throw new Error("Vocabulary key is not found.");g.push_back(d),g.push_back(m),p+=`\n  Src Vocab: ${f(d)}`,p+=`\n  Trg Vocab: ${f(m)}`}l&&(p+=`\n  QualityModel: ${f(l)}\n`);const h=c.generateTextConfig({"beam-size":"1",normalize:"1.0","word-penalty":"0","max-length-break":"128","mini-batch-words":"1024",workspace:"128","max-length-factor":"2.0","skip-cost":(!l).toString(),"cpu-threads":"0",quiet:"true","quiet-translation":"true","gemm-precision":i.model.record.name.endsWith("intgemm8.bin")?"int8shiftAll":"int8shiftAlphaAll",alignment:"soft"});return a(`Bergamot translation model config: ${h}`),a(p),new n.TranslationModel(t,r,h,s,o??null,g,l??null)}static allocateModelMemory(n,e){const t={};for(const[r,a]of Object.entries(e)){const e=s[r];if(!e)throw new Error(`Unknown file type: "${r}"`);const i=new n.AlignedMemory(a.buffer.byteLength,e);i.getByteArrayView().set(new Uint8Array(a.buffer)),t[r]=i}return t}static initializeWasm(n){return new Promise(((e,t)=>{let r=performance.now();const i=loadBergamot({INITIAL_MEMORY:41943040,print:a,onAbort(){t(new Error("Error loading Bergamot wasm module."))},onRuntimeInitialized:async()=>{a(`Bergamot wasm runtime initialized in ${(performance.now()-r)/1e3} seconds.`),await Promise.resolve(),e(i)},wasmBinary:n})}))}static mapVector(n,e){const t=[];for(let r=0;r<n.size();r++)t.push(e(n.get(r),r));return t}static generateTextConfig(n){const e="            ";let t="\n";for(const[r,a]of Object.entries(n))t+=`${e}${r}: ${a}\n`;return t+e}static getTranslationArgs(n,e,t){const r=new n.VectorString,a=new n.VectorResponseOptions;return e&&(r.push_back(e),a.push_back({qualityScores:!1,alignment:!0,html:t})),{messages:r,options:a}}}class m{constructor(n,e){this.sourceLanguage=n,this.targetLanguage=e}translate(n,e){const t=performance.now();let r=e?", html":"";return{targetText:`${n.toUpperCase()} [${this.sourceLanguage} to ${this.targetLanguage}${r}]`,inferenceMilliseconds:performance.now()-t}}discardTranslations(){}}class f{#r=100;#a=20;#i=new Map;#s=!1;#o=!1;#u=this.#a;constructor(n){this.innerWindowId=n}runTask(n,e){return this.#u>0?(this.#u--,Promise.resolve(e())):new Promise(((t,r)=>{this.#i.set(n,{task:e,resolve:t,reject:r}),this.#l().catch((n=>console.error(n)))}))}cancelTask(n){this.#i.delete(n)}async#l(){if(this.#s)return;this.#s=!0;let t=null,r=0;const a=()=>{n("TranslationsWorker WorkQueue",{startTime:t,innerWindowId:this.innerWindowId},`WorkQueue processed ${r} tasks`)};for(;this.#i.size&&!this.#o;){const n=e();if(null===t?(t=n,await new Promise((n=>setTimeout(n,0)))):n-t>this.#r&&(await new Promise((n=>setTimeout(n,0))),a(),t=e()),this.#o||!this.#i.size)break;r++;const[i,s]=this.#i.entries().next().value,{task:o,resolve:u,reject:l}=s;this.#i.delete(i);try{const n=await o();if(this.#o)break;u(n)}catch(n){l(n)}}a(),this.#s=!1}async cancelWork(){this.#o=!0,this.#i=new Map,await new Promise((n=>setTimeout(n,0))),this.#o=!1}}})()})();